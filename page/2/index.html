<!doctype html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Blue的博客">
<meta property="og:url" content="https://singthi4079.github.io/page/2/index.html">
<meta property="og:site_name" content="Blue的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blue的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://singthi4079.github.io/page/2/"/>





  <title> Blue的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blue的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/25/Java高并发程序设计读书笔记-并发模式与算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/25/Java高并发程序设计读书笔记-并发模式与算法/" itemprop="url">
                  Java高并发程序设计读书笔记-并发模式与算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-25T22:19:33+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用于产生一个对象的具体实例, 可以确保系统中一个类只产生一个实例.</p>
<p>单例模式的好处:</p>
<ul>
<li>对频繁使用的对象, 可以省略new操作花费的时间.</li>
<li>由于new操作减少, 系统内存的使用频率也会降低, 减轻GC压力, 缩短GC停顿时间.</li>
</ul>
<p>简单的单例实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Singleton is create"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式实现的单例模式有一点不足: Singleton实例在什么时候创建是不受控制的. 静态成员instance, 会在类第一次初始化的时候被创建, 这个时候并不一定是getInstance()方法第一次被调用的时候.</p>
<p>如果你的单例是这样实现的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATUS = <span class="number">1</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Singleton is create"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在任何地方引用这个STATUS都会导致instance实例被创建. 任何对Singleton方法或者字段的引用, 都会导致这个类初始化, 并创建instance实例. 但类初始化只有一次, 因此instance实例永远只会被创建一次.</p>
<p>在需要精确控制instance的创建时间的场合下, 这种方式是不友善的.</p>
<p>使用延迟加载的单例模式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </div><div class="line">      instance = <span class="keyword">new</span> LazySingleton();</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式只有在调用getInstance()方法时才会创建instance实例.</p>
<p>为了防止对象被多次创建, 必须使用synchronized进行方法同步.</p>
<p>一种结合两者优势的单例模式实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instace = <span class="keyword">new</span> StaticSingleton();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先 getInstance() 方法中没有锁, 在高并发环境下性能优越.</p>
<p>其次 getInstance()方法被第一次调用时, StaticSingleton的实例才会被创建. 这里使用了内部类和类的初始化方式. </p>
<p>内部类SingletonHolder被声明为private, 不可能在外部访问并初始化它. </p>
<h3 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h3><p>当多线程对同一个对象进行读写操作时, 为保证数据的一致性和正确性, 有必要对对象进行同步. 而同步操作对系统性能有相当的损耗.</p>
<p>使用不可改变的对象, 可以尽可能的去除同步操作, 提高并行程序性能. 依靠对象的不变性, 可以确保在没有同步操作的多线程环境中依然始终保持内部状态的一致性和正确性. 这就是不变模式.</p>
<p>核心思想: 一个对象一旦被创建, 则它的内部状态将永远不会发生改变. 所以, 没有一个线程可以修改其内部状态和数据, 同时其内部状态也绝不会自行发生改变.</p>
<p>不变模式和只读属性有一定的区别. 对只读属性的对象而言, 对象本身不能被其他线程修改, 但对象的自身状态却可以自行修改.</p>
<p>不变模式要求, 无论出于什么原因, 对象自创建后, 其内部状态和数据保持绝对的稳定.</p>
<p>使用场景需要满足以下2个条件:</p>
<ol>
<li>当对象创建后, 其内部状态和数据不再发生任何变化</li>
<li>对象需要被共享, 被多线程频繁访问</li>
</ol>
<p>为保证对象被创建后不再发生任何改变, 并保证不变模式正常工作, 需要注意以下4点:</p>
<ol>
<li>去除setter方法以及所有修改自身属性的方法</li>
<li>将所有属性设置为私有, 并用<code>final</code>标记, 确保其不可修改</li>
<li>确保没有子类可以重载修改它的行为</li>
<li>有一个可以创建完整对象的构造函数</li>
</ol>
<p>以下实现了一个不变的产品对象: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  <span class="comment">// 确保无子类</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String no;  <span class="comment">// 私有属性, 不会被其他对象获取</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;  <span class="comment">// final 保证属性不会被2次修改</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> price;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String no, String name, <span class="keyword">double</span> price)</span> </span>&#123;  <span class="comment">// 创建对象时, 必须指定数据, 因为创建后就不能修改</span></div><div class="line">    <span class="keyword">this</span>.no = no;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  getter.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JDK中主要的不变模式类型:</p>
<ul>
<li>java.lang.String</li>
<li>java.lang.Boolean</li>
<li>java.lang.Byte</li>
<li>java.lang.Short</li>
<li>java.lang.Integer</li>
<li>java.lang.Long</li>
<li>java.lang.Float</li>
<li>java.lang.Double</li>
<li>java.lang.Character</li>
</ul>
<blockquote>
<p>不变模式通过回避问题, 来处理多线程并发问题. 不变模式可以提高系统的并发性能和并发量</p>
</blockquote>
<h3 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h3><p>生产者-消费者模式为多线程间的协作提供了良好的解决方案</p>
<p>在生产者-消费者模式中, 通常有两种线程, 即若干个生产者线程和若干个消费者线程, 生产者线程负责提交用户请求, 消费者线程负责具体的处理生产者提交的任务. 生产者和消费者之间通过共享内存缓冲区进行通信.</p>
<blockquote>
<p>生产者-消费者模式中, 内存缓冲区的主要功能是数据在多线程间的共享, 此外, 通过该缓冲区, 可以缓解生产者和消费者之间的性能差异</p>
</blockquote>
<p>内存缓冲区作为生产者和消费者间通信的桥梁, 避免生产者和消费者直接通信, 将生产者和消费者解耦.</p>
<table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">生产者</td>
<td style="text-align:center">用于提交用户请求, 提取用户任务, 并装入内存缓冲区</td>
</tr>
<tr>
<td style="text-align:center">消费者</td>
<td style="text-align:center">在内存缓冲区中提取并处理任务</td>
</tr>
<tr>
<td style="text-align:center">内存缓冲区</td>
<td style="text-align:center">缓存生产者提交的任务或数据, 供消费者使用</td>
</tr>
<tr>
<td style="text-align:center">任务</td>
<td style="text-align:center">生产者向内存缓冲区提交的数据结构</td>
</tr>
<tr>
<td style="text-align:center">Main</td>
<td style="text-align:center">使用生产者和消费者的客户端</td>
</tr>
</tbody>
</table>
<p>以下基于生产者-消费者模式的求整数平方的并行程序:</p>
<p><strong>生产者线程的实现, 它构建PCData对象, 并存放到BlockingQueue队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;  </div><div class="line">  <span class="keyword">private</span> BlockingQueue&lt;PCData&gt; queue;  <span class="comment">// 内存缓冲区</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count;  <span class="comment">// 总数, 原子操作</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPTIME = <span class="number">1000</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(BlockingQueue&lt;PCData&gt; queue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.queue = queue;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    PCData data = <span class="keyword">null</span>;</div><div class="line">    Random r = <span class="keyword">new</span> Random();</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"start producer id="</span> + Thread.currentThread().getId());</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (isRunning) &#123;</div><div class="line">        Thread.sleep(r.nextInt(SLEEPTIME));</div><div class="line">        data = <span class="keyword">new</span> PCData(count.incrementAndGet());</div><div class="line">        System.out.println(data + <span class="string">"is put into queue"</span>);</div><div class="line">        <span class="keyword">if</span> (!queue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS)) &#123; <span class="comment">// 提交数据到缓冲区</span></div><div class="line">          System.err.println(<span class="string">"failed to put data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterrupedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">      Thread.currentThread().interrupe();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>消费者实现, 从BlockingQueue中取出PCData对象, 并进行相应的计算</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> BlockingQueue queue;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPTIME = <span class="number">1000</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.queue = queue;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"start producer id="</span> + Thread.currentThread().getId());</div><div class="line">    Random r = <span class="keyword">new</span> Random();</div><div class="line">    </div><div class="line">    <span class="keyword">try</span> (</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        PCData data = queue.take();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != data) &#123;</div><div class="line">          <span class="keyword">int</span> re = data.getData() + data.getData();</div><div class="line">          Thread.sleep(r.nextInt(SLEEPTIME));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ) <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">      Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>PCData作为生产者和消费者之间的共享数据模型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PCData</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> intData;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PCData</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">    intData = d;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> intData;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"data:"</span> + intData;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在主函数中, 创建三个生产者和三个消费者, 并让它们协作允许。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    BlockingQueue&lt;PCData&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;PCData&gt;(<span class="number">10</span>);</div><div class="line">    Product producter1 = <span class="keyword">new</span> product(queue);</div><div class="line">    Product producter2 = <span class="keyword">new</span> Product(queue);</div><div class="line">    Product producter3 = <span class="keyword">new</span> Product(queue);</div><div class="line">    </div><div class="line">    Consumer consumer1 = <span class="keyword">new</span> Consumer(queue);</div><div class="line">    Consumer consumer2 = <span class="keyword">new</span> Consumer(queue);</div><div class="line">    Consumer consumer3 = <span class="keyword">new</span> Consumer(queue);</div><div class="line">    </div><div class="line">    ExecutorService service = Executors.newCachedThreadPool();</div><div class="line">    service.executer(producter1);</div><div class="line">    service.executer(producter2);</div><div class="line">    service.executer(producter3);</div><div class="line">    service.executer(consumer1);</div><div class="line">    service.executer(consumer2);</div><div class="line">    service.executer(consumer3);</div><div class="line">    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</div><div class="line">    producter1.stop();</div><div class="line">    producter2.stop();</div><div class="line">    producter3.stop();</div><div class="line">    Thread.sleep(<span class="number">3000</span>);</div><div class="line">    service.sutdown();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h3><p>Future模式的核心思想是异步调用. 对Future模式来说, 虽然无法立即给出需要的数据, 但它会返回一个契约, 将来, 可以凭借契约重新获取需要的数据.</p>
<p>Future模式的主要角色:</p>
<table>
<thead>
<tr>
<th style="text-align:center">参与者</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Main</td>
<td style="text-align:center">系统启动, 调用Client发出请求</td>
</tr>
<tr>
<td style="text-align:center">Client</td>
<td style="text-align:center">返回Data对象, 立即返回FutureData, 并开启ClientThread线程装配RealData</td>
</tr>
<tr>
<td style="text-align:center">Data</td>
<td style="text-align:center">返回数据的接口</td>
</tr>
<tr>
<td style="text-align:center">FutureData</td>
<td style="text-align:center">Future数据, 构造快, 但是是一个虚拟数据, 需要装配RealData</td>
</tr>
<tr>
<td style="text-align:center">RealData</td>
<td style="text-align:center">真是数据, 其构造比较慢</td>
</tr>
</tbody>
</table>
<p>简单实现: </p>
<p><strong>核心接口, 客户端希望获得的数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>FutureData实现了一个快速返回的RealData包装</strong></p>
<p>当使用FutureData的getResult()方法时, 如果实际数据没有准备好, 程序会阻塞, 等待RealData准备好并注入到FutureData中. 才返回最终数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> RealData realData = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isReady) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">this</span>.realData = realData;</div><div class="line">    isReady = <span class="keyword">true</span>;</div><div class="line">    notifyAll();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isReady) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        wait();</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> realData.result();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>FutureData是Future模式的关键, 它实际上是RealData的代理, 封装了获取RealData的等待过程</p>
</blockquote>
<p><strong>RealData是最终需要使用的数据.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String result;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span> </span>&#123;</div><div class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">      sb.append(para);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    result = sb.toString();</div><div class="line">  &#125; </div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>**Client主要实现获取FutureData, 并开启构造RealData的线程, 并在接受请求后, 快速返回FutureData.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String queryStr)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        RealData realData = <span class="keyword">new</span> RealData(queryStr);</div><div class="line">        future.setRealData(realData);</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">    <span class="keyword">return</span> future;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Main函数主要负责调用Client发起请求, 并消费返回的数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  client client = <span class="keyword">new</span> Client();</div><div class="line">  Data data = client.request(<span class="string">"name"</span>);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">2000</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">  System.out.println(<span class="string">"数据:"</span> + data.getResult()); <span class="comment">//使用真实数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="并行流水线"><a href="#并行流水线" class="headerlink" title="并行流水线"></a>并行流水线</h3><p>假设现在有两个数, B和C. 要计算<code>(B+C)*B/2</code>, 这个运行过程是无法并行的. 这种情况可以借鉴流水线的思想.</p>
<p>先将计算过程拆分为三个步骤:</p>
<p>P!: A = B + C</p>
<p>P2: D = A*B</p>
<p>P3: D = D/2</p>
<p>P1,P2,P3均在单独的线程中计算, 并且每个线程之负责自己的工作. 此时, P3的计算结果就是最终答案.</p>
<h3 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h3><p>给定一个数组, 要查找出满足条件的元素. 使用并行方式, 需要额外增加一个线程间通信机制, 使各个线程可以有效的运行. </p>
<p>将原始数据集合按期望的线程数进行分割.  每个线程独立搜索, 当一个线程找到数据后, 立即返回即可.</p>
<h3 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h3><p><strong>奇偶交换排序</strong></p>
<p>在冒泡排序的执行过程中, 如果数据比较小, 它会逐步被交换到前面去. 较大的数字, 会下沉, 交换到数组的末尾.</p>
<p>冒泡排序的一般算法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=arr.length-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</div><div class="line">      <span class="keyword">if</span> (arr[j] ? arr[j+<span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[j];</div><div class="line">        arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">        arr[j+<span class="number">1</span>] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>奇偶交换排序将排序过程分为两个阶段: 奇交换和偶交换.</p>
<p>奇交换: 总是比较奇数索引以及其相邻的后续元素</p>
<p>偶交换: 总是比较偶数索引和其相邻的后续元素.</p>
<p>并且奇交换和偶交换会成对出现. 这样才能保证比较和交换涉及到数组中的每一个元素.</p>
<p>奇偶交换排序的并行实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> exchFlag = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setExchFlag</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; exchFlag = v; &#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getExchFlag</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> exchFlag; &#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OddEvenSortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  CountDownLatch latch;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OddEvenSortTask</span><span class="params">(<span class="keyword">int</span> i, CountDownLatch latch)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.i = i;</div><div class="line">    <span class="keyword">this</span>.latch = latch</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</div><div class="line">      <span class="keyword">int</span> temp = arr[i];</div><div class="line">      arr[i] = arr[i+<span class="number">1</span>];</div><div class="line">      arr[i+<span class="number">1</span>] = temp;</div><div class="line">      setExchFlag(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    latch.countDown();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pOddEvenSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (getExchFlag() == <span class="number">1</span> || start == <span class="number">1</span>) &#123;</div><div class="line">    setExchFlag(<span class="number">0</span>);</div><div class="line">    <span class="comment">// 偶数的数组长度, 当start=1时, 只有len/2-1个线程</span></div><div class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(arr.length/<span class="number">2</span>-(arr.length%<span class="number">2</span>==<span class="number">0</span>?start:<span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;arr.length-<span class="number">1</span>; i+=<span class="number">2</span>) &#123;</div><div class="line">      pool.submit(<span class="keyword">new</span> OddEvenSortTask(i, latch));</div><div class="line">    &#125;</div><div class="line">    latch.await();</div><div class="line">    <span class="keyword">if</span> (start == <span class="number">0</span>) start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> start = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>希尔排序</strong></p>
<p>插入排序是一种很常用的排序算法. 基本思想是: 一个未排序的数组, 可以分为两个部分, 前半部分是已经排序的, 后半部分是未排序的. 在进行排序时, 只需要在为排序的部分选择一个元素, 将其插入到有序的数组中即可. 初始时, 可以假设以排序部分就是第一个元素.</p>
<p>插入排序实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> lenght = arr.length;</div><div class="line">  <span class="keyword">int</span> j, i, key;</div><div class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;length; i++) &#123;</div><div class="line">    key = arr[i];</div><div class="line">    j = i-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</div><div class="line">      arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    arr[j+<span class="number">1</span>] = key;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>希尔排序把整个数组根据间隔h分割为若干个子数组, 子数组相互穿插在一起, 每一次排序时, 分别对每一个子数组进行排序. </p>
<p>在每一组排序完成后,  可以递减h的值, 进行下一轮更加精细的排序. 直到h=1, 此时等价于一次插入排序.</p>
<p>希尔排序的优点: 即使一个较小的元素在数组的末尾, 由于每次元素移动都以h为间隔进行, 因此数组末尾的小元素可以在很少的交换次数下, 就被置换到最接近元素最终的位置的地方.</p>
<p>希尔排序的实现: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i=<span class="number">0</span>; </div><div class="line">  <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">  CountDownLatch l;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShellSortTask</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> h, CountDownLatch latch)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.i=i;</div><div class="line">    <span class="keyword">this</span>.h=h;</div><div class="line">    <span class="keyword">this</span>.l=latch;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[i-h]) &#123;</div><div class="line">      <span class="keyword">int</span> temp = arr[i];</div><div class="line">      <span class="keyword">int</span> j = i-h;</div><div class="line">      <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp) &#123;</div><div class="line">        arr[j+h] = arr[j];</div><div class="line">        j -= h;</div><div class="line">      &#125;</div><div class="line">      arr[j+h] = temp;</div><div class="line">    &#125;</div><div class="line">    l.countDown();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pShellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  <span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">  CountDownLatch latch = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">while</span> (h&lt;=arr.length/<span class="number">3</span>) &#123;</div><div class="line">    h = h*<span class="number">3</span> + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (h &gt; <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(<span class="string">"h="</span> + h);</div><div class="line">    <span class="keyword">if</span> (h &gt;= <span class="number">4</span>) &#123;</div><div class="line">      latch = <span class="keyword">new</span> CountDownLatch(arr.lenght - h);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=h; i&lt;arr.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (h &gt;= <span class="number">4</span>) </div><div class="line">        pool.execute(<span class="keyword">new</span> ShellSortTask(i, h, latch));</div><div class="line">      <span class="keyword">else</span>  &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - h]) &#123;</div><div class="line">          <span class="keyword">int</span> temp = arr[i];</div><div class="line">          <span class="keyword">int</span> j = i-h;</div><div class="line">          <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</div><div class="line">            arr[j+h] = arr[j];</div><div class="line">            j -= h;</div><div class="line">          &#125;</div><div class="line">          arr[j+h] = temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    latch.await();</div><div class="line">    h = (h-<span class="number">1</span>)/<span class="number">3</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/24/Java高并发程序设计读书笔记-锁优化及注意事项-无锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/24/Java高并发程序设计读书笔记-锁优化及注意事项-无锁/" itemprop="url">
                  Java高并发程序设计读书笔记-锁优化及注意事项-无锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T21:26:32+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对并发控制而言,  锁是一种悲观的策略. 总是假设每次对临界区操作都会产生冲突.</p>
<p>无锁是一种乐观的策略, 它假设对资源的访问没有冲突. 无锁的策略使用比较交换技术(CAS Compare And Swap)来鉴别线程冲突, 一旦检测到冲突发送, 就重试当前操作直到没有冲突为止.</p>
<h3 id="比较交换-CAS"><a href="#比较交换-CAS" class="headerlink" title="比较交换(CAS)"></a>比较交换(CAS)</h3><p>CAS技术对死锁问题天生免疫.</p>
<p>使用无锁方式完全没有锁竞争带来的系统开销, 也没有线程间频繁调度带来的开销. 因此, 它比基于锁的方式拥有更优越的性能.</p>
<p>CAS的算法过程:</p>
<p>包含三个参数CAS(V, E, N). V表示要更新的变量, E表示预期值, N表示新值.</p>
<p>仅当V==E时, 才会将V的值设置为N</p>
<p>如果V!=E, 说明有其他线程做了更新, 则当前线程什么都不做.</p>
<p>CAS返回当前V的真实值.</p>
<p>当多个线程同时使用CAS操作一个变量时, 只有一个会胜出, 并成功更新, 其余均会失败. 失败的线程不会被挂起, 仅会被告知失败, 并且允许再次尝试, 也允许失败的线程放弃操作.</p>
<p>CAS需要硬件层面的支持(CPU是否支持CAS指令).</p>
<h3 id="无锁的线程安全整数-AtomicInteger"><a href="#无锁的线程安全整数-AtomicInteger" class="headerlink" title="无锁的线程安全整数(AtomicInteger)"></a>无锁的线程安全整数(AtomicInteger)</h3><p>JDK并发包中有一个atomic包, 里面实现了一些直接使用CAS操作的线程安全的类型.</p>
<p>AtomicInteger的主要方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;  <span class="comment">// 取得当前值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;  <span class="comment">// 设置当前值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;  <span class="comment">// 设置新值, 并返回旧值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> u)</span></span>;  <span class="comment">// 如果当前值为expect, 则设置为u</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>;  <span class="comment">// 当前值加1, 返回旧值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span></span>;  <span class="comment">// 当前值减1, 返回旧值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAddAdd</span><span class="params">(<span class="keyword">int</span> delta)</span></span>;  <span class="comment">//当前值加delta, 返回旧值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>;  <span class="comment">// 当前值加1, 返回新值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAdnGet</span><span class="params">()</span></span>;  <span class="comment">// 当前值减1, 返回新值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span></span>;  <span class="comment">// 当前值加delta, 返回新值</span></div></pre></td></tr></table></figure>
<p>AtomicInteger内部保存一个核心字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</div></pre></td></tr></table></figure>
<p>它表示AtomicInteger当前实际值. 还有一个:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ling valueOffset;</div></pre></td></tr></table></figure>
<p>保存着value字段在AtomicInteger对象中的偏移量.</p>
<p>AtomicInteger的简单示例: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">1000</span>; k++) </div><div class="line">        i.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    Thread[] ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</div><div class="line">      ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</div><div class="line">      ts[k].start();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>; k++) &#123;</div><div class="line">      ts[k].join();</div><div class="line">    &#125;</div><div class="line">    System.out.println(i);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>incrementAndGet()方法的内部实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">    <span class="keyword">int</span> current = get();</div><div class="line">    <span class="keyword">int</span> next = current + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line">      <span class="keyword">return</span> next;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get()方法就是返回内部数据value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>incrementAndGet()方法中使用死循环的原因:</p>
<p>CAS操作不一定能成功, 如果不成功, 就需要不断尝试. </p>
<p>使用get()方法获取当前值, 然后加1得到新值next; 这样就得到了CAS必须的两个参数.</p>
<h3 id="Java中的指针-Unsafe类"><a href="#Java中的指针-Unsafe类" class="headerlink" title="Java中的指针(Unsafe类)"></a>Java中的指针(Unsafe类)</h3><p>AtomicInteger类中incrementAndGet()方法的compareAndSet()方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> unsafe.compareAndSwap(<span class="keyword">this</span>, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>unsafe是sum.misc.Unsafe类型. Unsafe类封装了一些类似指针的操作. compareAndSwapInt()方法是一个native方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">publc <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>o: 给定对象</li>
<li>offset: 为对象内的偏移量, 一个字段到对象头部的偏移量. 可以快速定位字段</li>
<li>expected: 期望值</li>
<li>x: 表示要设置的值</li>
</ul>
<p>如果指定的字段的值等于expected, 那就把它设置为x.</p>
<p>compareAndSwapInt()内部必然是用CAS原子指令完成.</p>
<p>Unsafe类还提供一些方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;  <span class="comment">// 获取给定对象偏移量上的int值</span></div><div class="line"><span class="comment">// 设置给定对象偏移量上的int值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</div><div class="line"><span class="comment">// 获得字段在对象上的偏移量</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</div><div class="line"><span class="comment">// 设置给定对象的int值, 使用volatile语义</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</div><div class="line"><span class="comment">// 获取给定对象的int值, 使用volatile语义</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</div><div class="line"><span class="comment">// 和putIntVolatile一样, 但要求被操作数必须是volatile类型</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="无锁的对象引用-AtomicReference"><a href="#无锁的对象引用-AtomicReference" class="headerlink" title="无锁的对象引用(AtomicReference)"></a>无锁的对象引用(AtomicReference)</h3><p>AtomicReference和AtomicInteger类似, 不同的是, AtomicInteger是对整数的封装, 而AtomicReference是对普通对象的引用. </p>
<p>它可以保证在修改对象时的线程安全性.</p>
<p>原子操作的逻辑上的不足: 当获得对象当前数据后, 在准备修改为新值前, 对象的值被其他线程连续修改了两次, 而经过两次修改后, 对象有恢复了旧值. </p>
<p>这样, 当前线程就无法正确判断这个对象究竟是否被修改过.</p>
<p>AtomicStampedReference可以解决这个问题.</p>
<p>AtomicReference无法解决上述问题的根本是因为对象在修改的过程中, 丢失了状态信息. 对像值本身与状态被画上了等号.</p>
<p>只要能搞记录对象在修改过程中的状态值, 就可以很好的解决对象被反复修改导致无法正确判断对象状态的问题. AtomicStampedReference就是这么做的.</p>
<p>AtomicStampedReference内部不仅维护对象值, 还维护一个时间戳. </p>
<p>当AtomicStampedReference被修改时, 除了更新数据本身外, 还必须更新时间戳. </p>
<p>当Atomicstampedeference设置对象值时, 对象值以及时间戳都必须满足期望值, 写入才会成功. </p>
<p>AtomicStampedReference的几个API在AtomicReference的基础上增加了有关时间戳的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比较设置, 参数依次为: 期望值, 写入新值, 期望时间戳, 写入时间戳</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectedReference, V newReferece, <span class="keyword">int</span> expectedStamp, <span class="keyword">int</span> newStamp)</span></span>;</div><div class="line"><span class="comment">// 获取当前对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 获取当前时间戳</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 设置当前对象引用和时间戳</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span>;</div></pre></td></tr></table></figure>
<p>使用AtomicStampedReference实现贵宾卡充值的问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; money = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">19</span>, <span class="number">0</span>);</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 模拟多个线程同时更新后台数据, 为用户充值</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> timestamp = money.getStamp();</div><div class="line">      <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">              Integer m = money.getReference();</div><div class="line">              <span class="keyword">if</span> (m &lt; <span class="number">20</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (money.compareAndSet(m, m+<span class="number">20</span>, timestamp, timestamp+<span class="number">1</span>)) &#123;</div><div class="line">                  System.out,println(<span class="string">"余额小于20元, 充值成功, 余额: "</span> + money.getReference() + <span class="string">"元."</span>);</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;.start();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 用户消费线程, 模拟消费行为</span></div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">int</span> timestamp = money.getStamp();</div><div class="line">            Integer m = money.getReference();</div><div class="line">            <span class="keyword">if</span> (m &gt; <span class="number">10</span>) &#123;</div><div class="line">              System.out.println(<span class="string">"大于10元"</span>);</div><div class="line">              <span class="keyword">if</span> (money.compareAndSet(m, m-<span class="number">10</span>, timestamp, timestamp+<span class="number">1</span>)) &#123;</div><div class="line">                System.out.println(<span class="string">"成功消费10元, 余额: "</span> + money.getReference());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              System.out.println(<span class="string">"没有足够的金额"</span>);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样账号只会被赠与一次;</p>
<h3 id="数组也能无锁-AtomicIntegerArray"><a href="#数组也能无锁-AtomicIntegerArray" class="headerlink" title="数组也能无锁(AtomicIntegerArray)"></a>数组也能无锁(AtomicIntegerArray)</h3><p>JDK提供的原子数组有: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray. 分别表示: 整数数值, long型数组, 普通对象数组</p>
<p>AtomicIntegerArray本质上是对int[]类型的封装, 使用Unsafe类通过CAS的方式控制int[]在对线程下的安全性.</p>
<p>核心API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获得数组的第i个下标的元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> in <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="comment">// 获取数组的长度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 将数组第i个下标设置为newValue, 放回旧值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span></span>;</div><div class="line"><span class="comment">// 进行CAS操作, 如果第i个下标的元素等于expect, 则设置为update, 设置成功返回true</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span>;</div><div class="line"><span class="comment">// 将第i个下标元素加1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="comment">// 将第i个下标元素减1</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="comment">// 将第i个下标元素加delta</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="让普通变量拥有原子操作-AtomicIntegerFieldUpdater"><a href="#让普通变量拥有原子操作-AtomicIntegerFieldUpdater" class="headerlink" title="让普通变量拥有原子操作(AtomicIntegerFieldUpdater)"></a>让普通变量拥有原子操作(AtomicIntegerFieldUpdater)</h3><p>有时, 需要将一些普通变量改为线程安全的. 如果改动不大, 可以值修改程序中每一个使用或者读取这个变量的地方. 但这并不符合开闭原则. 即: 系统对功能增加应该是开放的, 对修改应该是相对保守的.</p>
<p>AtomicIntegerFieldUpdater可以在极少改动原有代码的基础上,  让普通变量享有CAS操作带来的线程安全.</p>
<p>JDK提供了AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater, 分别是对int, long, 普通对象进行CAS修改.</p>
<p>注意事项:</p>
<ul>
<li>Updater只能修改它可见范围内的变量. 因为Updater使用反射得到这个变量.</li>
<li>为确保变量被正确的读取, 它必须是volatile类型的. </li>
<li>由于CAS操作会通过对象实例中的偏移量直接进行赋值, 因此, 它不支持static字段.(Unsafe.objectFieldOffset()不支持静态变量) </li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/23/Java高并发程序设计读书笔记-锁优化及注意事项-ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/23/Java高并发程序设计读书笔记-锁优化及注意事项-ThreadLocal/" itemprop="url">
                  Java高并发程序设计读书笔记-锁优化及注意事项-ThreadLocal
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-23T22:17:17+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>除了控制资源的访问外, 还可以通过增加资源来保证所有对象的线程安全.</p>
<p>ThreadLocal表示一个线程的局部变量, 只有当前线程可用访问. 所以是线程安全的.</p>
<p>ThreadLocal的简单示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.i = i;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (t1.get() == <span class="keyword">null</span>) &#123;</div><div class="line">        t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">      &#125;</div><div class="line">      Date t = t1.get().parse(<span class="string">"2015-03-29 19:29:"</span>+i%<span class="number">60</span>);</div><div class="line">      System.out.println(i + <span class="string">":"</span> + t);</div><div class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在应用上为每一个线程分配了相同的对象实例, 那ThreadLocal也不能保证线程安全.</p>
<blockquote>
<p>为每一个线程分配不通的对象, 需要在应用层面保证. ThreadLocal只是起到简单的容器作用</p>
</blockquote>
<h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的set()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">  Thread t = Thread.currentThread();</div><div class="line">  ThreadLocalMap map = getMap(t);</div><div class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">    map.set(<span class="keyword">this</span>, value);</div><div class="line">  <span class="keyword">else</span> </div><div class="line">    createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocalMap是定义在Thread内部的成员. 设置数据, 就是写入到ThreadLocalMap中. 而ThreadLocalMap本身就保存了所在线程的所有”局部变量”, 也就是一个ThreadLocal变量的集合.</p>
<p>ThreadLocal的get()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  Thread t = Thread.currentThread();</div><div class="line">  ThreadLocalMap map = getMap(t);</div><div class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">    ThreadLocalMap.Entry e = map.getEntity(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">      <span class="keyword">return</span> (T) e.value;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些变量是维护在Thread类内部的, 只要线程不退出, 对象的引用就将一只存在.</p>
<p>当线程退出Thread类会进行一些清理工作, 包括清理ThreadLocalMap:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</div><div class="line">        group.threadTerminated(<span class="keyword">this</span>);</div><div class="line">        group = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/* 加速资源清理 */</span></div><div class="line">    threadLocals = <span class="keyword">null</span>;</div><div class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</div><div class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</div><div class="line">    blocker = <span class="keyword">null</span>;</div><div class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用线程池, 那当前线程不一定会退出. 如果将一些很大的对象设置到ThreadLocal中(实际保存在Thread中的ThreadLocalMap对象), 可能会出现内存泄漏的可能(对象不再有用, 但却无法被回收).</p>
<p>调用ThreadLocal.remove()方法可以将这个变量移除, 是它可以被回收.</p>
<p>也可以把ThreadLocal对象设置为null, 使得这个ThreadLocal对应的所有线程的局部变量都有可能被回收.</p>
<p>ThreadLocalMap类似WeakHashMap, 使用弱引用, JVM在垃圾回收时, 如果发现弱引用, 就会立即回收. ThreadLocalMap由一系列Entry构成, 每个Entry都是<code>WeakReference&lt;ThreadLocal&gt;</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">  Object value;</div><div class="line">  Entry (ThreadLocal k, Object v) &#123;</div><div class="line">    <span class="keyword">super</span>(k);</div><div class="line">    value = v;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/23/Java高并发程序设计读书笔记-锁优化及注意事项-几点建议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/23/Java高并发程序设计读书笔记-锁优化及注意事项-几点建议/" itemprop="url">
                  Java高并发程序设计读书笔记-锁优化及注意事项-几点建议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-23T21:01:59+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>锁的竞争必然会导致程序的整体性能下降. 一下几点建议可以优化程序性能.</p>
<h3 id="减小锁持有时间"><a href="#减小锁持有时间" class="headerlink" title="减小锁持有时间"></a>减小锁持有时间</h3><p>对于使用锁进行并发控制的程序而言, 锁竞争过程中, 单个线程对锁的持有时间与系统性能有直接关系.</p>
<p>持有锁时间长, 锁的竞争程度就越激励. 应该尽可能减少对某个锁的占有时间, 以减少线程间互斥的可能. 以下面的代码段为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">  othercode1();</div><div class="line">  mutextMethod();</div><div class="line">  othercode2();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设只有mutextMethod()方法需要同步, 而othercode1()和othercode2()不需要同步, 而且othercode1()和othercode2()需要较长的时间才能完成,  则syncMethod()方法会占用较长的CPU时间. </p>
<p>此时, 如果并发量较大, 会导致等待线程大量增加.</p>
<p>一个较为优化的解决方案, 只在必要时进行同步, 这样能减少线程持有锁的时间, 提高系统吞吐量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">  othercode1();</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    mutextMethod();</div><div class="line">  &#125;</div><div class="line">  othercode2();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><p>ConcurrentHashMap就是减小锁粒度的典型例子.</p>
<p>ConcurrentHashMap内部细分了若干个小的HashMap, 称之为段. 默认情况下, 一个ConcurrentHashMap被进一步细分为16个段.</p>
<p>在向ConcurrentHashMap添加下新的表项时, 首先根据hashcode得到该表项应该被存放在哪个段中, 然后对该段加锁, 并完成put()操作.</p>
<p>由于默认有16段, 因此ConcurrentHashMap可以接受16个线程同时插入. 大大的提升了吞吐量.</p>
<p>以下是put()操作的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">  Segment&lt;K, V&gt; s;</div><div class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) </div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">  <span class="keyword">int</span> hash = hash(key); <span class="comment">// 根据key, 获取对应的段号</span></div><div class="line">  <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; <span class="comment">// 根据key, 获取对应的段号</span></div><div class="line">  <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT)) == <span class="keyword">null</span>))</div><div class="line">    s == ensureSegment(j);</div><div class="line">  <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所谓减小锁粒度, 就是指缩小锁定对象的范围, 减少锁冲突的可能性, 提高系统并发能力.</p>
<h3 id="读写分离替换独占锁"><a href="#读写分离替换独占锁" class="headerlink" title="读写分离替换独占锁"></a>读写分离替换独占锁</h3><p>使用读写锁代替独占锁是减小锁粒度的一种特殊情况.</p>
<p>在读多写少的场合, 使用读写锁可以有效提高系统的并发能力</p>
<p>根据程序的功能特点, 使用类似的分离思想, 也可以对独占锁进行分离. java.util.concurrent.LinkedBlockingQueue的实现是典型案例.</p>
<p>take()函数和put()函数分别实现了从队列中取数和添加数据的功能, 虽然都是对队列进行修改操作, 但由于LinkedBlockingQueue基于链表, 两个操作分别作用于队头和队尾, 理论上两者并不冲突.</p>
<p>JDK使用两把不通的锁, 分离了take()和put()操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</div></pre></td></tr></table></figure>
<p>take()函数的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  E x;</div><div class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">  <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">  <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">  takeLock.lockInterruptibly();    <span class="comment">// 不能两个线程同时取数据</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (count.get() == <span class="number">0</span>) </div><div class="line">        notEmpty.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      notEmpty.signal();</div><div class="line">      <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    x = extract();    <span class="comment">// 取得第一个数据</span></div><div class="line">    c = count.getAndDecrement();    <span class="comment">// 数量减1, 原子操作因为会和put()函数同时范围count. 注意: 变量c是count-1前的值</span></div><div class="line">    <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">      notEmpty.signal();    <span class="comment">// 通知其他take()操作</span></div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    takeLock.unlock();   <span class="comment">// 释放锁</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (c == capacity) </div><div class="line">    signalNotFull();    <span class="comment">// 通知put()操作, 已有可用空间</span></div><div class="line">  <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数put()的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</div><div class="line">  <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">  <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">  <span class="keyword">final</span> AtomicInteget count = <span class="keyword">this</span>.count;</div><div class="line">  putLock.lockInterruptibly();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (count.get() == capacity) <span class="comment">// 如果队列已满, 等待</span></div><div class="line">        notFull.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      notFull.signal();  <span class="comment">// 通知未中断的线程</span></div><div class="line">      <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    insert(e);  <span class="comment">// 插入数据</span></div><div class="line">    c = count.getAndIncrement();  <span class="comment">// 更新总数, 变量c是count加1前的值</span></div><div class="line">    <span class="keyword">if</span> (c+<span class="number">1</span> &lt; capacity)</div><div class="line">      notFull.signal();    <span class="comment">// 有足够空间, 通知其他线程</span></div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    putLock.unlock();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) </div><div class="line">    signalNotEmpty();  <span class="comment">// 插入成功后, 通知take()操作取数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="JDK内部的锁优化策略"><a href="#JDK内部的锁优化策略" class="headerlink" title="JDK内部的锁优化策略"></a>JDK内部的锁优化策略</h3><h4 id="锁偏向"><a href="#锁偏向" class="headerlink" title="锁偏向"></a>锁偏向</h4><p>锁偏向是一种针对锁操作的优化手段. 核心思想是: 如果一个线程获得了锁, 那么锁就进入偏向模式. 当这个线程再次请求锁时, 不需要再做任何同步操作.</p>
<p>节省了锁申请的操作, 提高了程序的性能. 在几乎没有锁竞争的场合, 偏向锁拥有比较好的优化效果.</p>
<p>Java虚拟机参数: <code>-XX:+UseBiasedLocking</code>可用开启偏向锁</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>偏向锁失败, 虚拟机不会立即挂起线程. 会用一种称为轻量级锁的优化手段.</p>
<p>轻量级锁只是简单的将对象头部作为指针, 指向只有锁的线程堆栈的内部, 来判断一个线程是否持有锁对象. </p>
<p>如果获得轻量级锁成功, 则进入临界区. 如果失败, 表示锁被其他线程抢先争夺到了, 那当前线程的锁请求会膨胀为重量级锁.</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>锁膨胀后, 虚拟机为避免线程被挂起, 虚拟机会把锁变成自旋锁. </p>
<p>虚拟机会让当前线程做几个空循环, 在若干个循环后, 如果得到锁, 就进入临界区. 如果不能获得锁, 就挂起.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/18/Java高并发程序设计读书笔记-JDK并发包-并发容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/18/Java高并发程序设计读书笔记-JDK并发包-并发容器/" itemprop="url">
                  Java高并发程序设计读书笔记-JDK并发包-并发容器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-18T22:40:15+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDK提供的这些容器大部分都在java.util.concurrent包中.</p>
<ul>
<li>ConcurrentHashMap: 高效的并发HashMap. 线程安全的HashMap</li>
<li>CopyOnWriteArrayList: 和ArrayList是一族的. 在读多写少的场合, 性能比Vector要好很多</li>
<li>ConcurrentLinkedQueue: 高效的并发队列, 使用链表实现. 线程安全的LinkedList</li>
<li>BlockingQueue: 一个接口, JDK内部通过链表, 数组等方式实现这个接口. 表示阻塞队列, 适用于数据共享通道</li>
<li>ConcurrentShipListMap: 跳表的实现. 这是一个Map, 使用跳表的数据结构进行快速查找</li>
</ul>
<h3 id="线程安全的HashMap"><a href="#线程安全的HashMap" class="headerlink" title="线程安全的HashMap"></a>线程安全的HashMap</h3><p> 使用如下代码, 产生的HashMap是线程安全的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</div></pre></td></tr></table></figure>
<p>Collections.synchronizedMap()生成的Map, 将自己所有Map相关的功能交给传入的HashMap实现, 而自己主要负责保证线程安全.</p>
<p>SynchronizedMap内包装了一个Map:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializeable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; m;</div><div class="line">  <span class="keyword">final</span> Object mutex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过metex实现对这个m的互斥操作.</p>
<p>无论对Map的读取或者写入, 都需要获得mutex的锁, 这样性能并不是很好. </p>
<p>在高并发环境下, 可以使用ConcurrentHashMap.</p>
<h3 id="List的线程安全"><a href="#List的线程安全" class="headerlink" title="List的线程安全"></a>List的线程安全</h3><p>Vector是线程安全的, ArrayList不是.</p>
<p>LinkedList不是线程安全的.</p>
<p>可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;String&gt;());</div></pre></td></tr></table></figure>
<p>生成线程安全的List对象</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是高并发环境下性能最好的队列.</p>
<p>ConcurrentLinkedQueue定义的节点Node核心:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">volatile</span> E item;</div><div class="line">  <span class="keyword">volatile</span> Node&lt;E&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>item表示目标元素.</p>
<p>next表示当前Node的下一个元素</p>
<p>对Node操作时, 使用了CAS操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置当前Node的item值, 当前值等于cmp时, 将目标设置为val. casNext类似, 用来设置next字段</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;  <span class="comment">// cmp: 期望值, val: 设置目标值</span></div><div class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</div><div class="line">  UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(This, nextOffset, cmp, val);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConcurrentLinkedQueue的重要字段:</p>
<p>head: 表示链表的头部, 应用不为null</p>
<p>tail: 表示链表的尾部</p>
<p>都是Node类型.</p>
<p>ConcurrentLinkedQueue允许运行时链表处于多个不同的状态.</p>
<p>tail的更新并不是实时的, 在插入时, tail每次更新会跳跃两个元素.</p>
<p>ConcurrentLinkedQueue向队列天假元素的offer()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">  checkNotNull(e);</div><div class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;) &#123;</div><div class="line">    Node&lt;E&gt; q = p.next;</div><div class="line">    <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// p是最后一个节点</span></div><div class="line">      <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</div><div class="line">        <span class="comment">// 每2次, 更新下tail</span></div><div class="line">        <span class="keyword">if</span> (p != t) </div><div class="line">          casTail(t, newNode);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// CAS竞争失败, 再次尝试</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == q) &#123;</div><div class="line">      <span class="comment">// 遇到哨兵节点, 从头head开始便利</span></div><div class="line">      <span class="comment">// 但如果tail被修改, 则使用tail(因为可能被修改正确了)</span></div><div class="line">      p = (t != (t = tail)) ? t : head;</div><div class="line">    &#125; <span class="keyword">else</span> </div><div class="line">      <span class="comment">// 取下一个节点或者最后一个节点</span></div><div class="line">      p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个方法没有任何锁操作, 线程安全完全由CAS操作和队列的算法来保证.</p>
<p>当第一次加入元素时, 由于队列为空, 因此p.next为null. q == null成立. 并将p的next节点赋值为newNode, 也就是将新的元素加入到队列中. 此时p==t成立. 如果casNext()成功, 就程序直接返回. 失败, 则再进行一次循环, 直到成功.</p>
<p>增加第2个元素时, 由于t还在head的位置, 因此p.next执行实际的第一个元素. q!=null, 表示q不是最后一个节点. </p>
<p>队列中增加元素需要最后一个节点的位置, 因此, 循环开始查找最后一个节点. 程序进入else代码块, 获得最后一个节点. </p>
<p>此时, p实际上时执行链表的第一个元素, 而它的next为空(此时链表中只有一个元素), 故第二个循环时, q==null成立. p更新自己的next, 如果成功, 此时p!=t, 会更新t所在的位置, 将t移动到链表最后.</p>
<p>p==q的情况时由于遇到了哨兵节点. </p>
<p>哨兵节点是指next执行自己的节点. 主要表示要删除的节点或者空节点. </p>
<p>遇到哨兵节点时, 无法通过next获取后续节点, 因此可能直接返回head, 期望通过从表头开始遍历, 进一步查找到末尾.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = (t != (t = tail)) ? t : head;</div></pre></td></tr></table></figure>
<p>首先<code>!=</code>不是原子操作, 它可以被中断. 也就是说, 在执行<code>!=</code>时, 程序会先取得t的值, 再执行t=tail, 并取得新的t的值. 然后比较这两个值是否相等.</p>
<p>在并发环境下, 有可能获得左边的t值后, 右边的t值被其他线程修改. 这样t!=t可能成立</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>在读多写少的应用场景中, 由于读操作根本不会修改原有的数据, 每次读区都进行加锁是一种资源浪费.</p>
<p>读操作会被写操作阻碍, 当写发生时, 读就必须等待. 否则可能都到的不一致的数据.</p>
<p>CopyOnWriteArrayList类, 读操作完全不加锁, 并且写入也不会阻塞读取操作. 只有写入和写入之间需要进行同步等待.</p>
<p>CopyOnWriteArrayList会在写入操作时, 进行一次自我复制. 这个List在修改时, 并不少修改原有的数据, 而是把修改的内容写入副本中. 写完再将修改完的副本替换原来的数据.</p>
<p>读取的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> get(getArray(), index);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> Object[] getArray() &#123;</div><div class="line">  <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (E) a[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写入操作实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">  lock.lock();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Object[] elements = getArray();</div><div class="line">    <span class="keyword">int</span> len = elements.length;</div><div class="line">    Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">    newElements[len] = e;</div><div class="line">    setArray(newElements);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为array变量是volatile类型, 所以在新的数组替换掉老的数组时(setArray()方法), 读取线程会立即”察觉”到这个修改.</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>ArrayBlockingQueue基于数组实现, 适合做有界队列. 因为队列的容量在队列创建时就指定了.</p>
<p>LinkedBlockingQueue基于链表实现, 适合做无界队列. 起内部元素可以动态添加, 不会因为初始容量很大, 吃到太多内存.</p>
<p>服务线程指不懂获取队列中的消息, 进行处理的线程.</p>
<p>BlockingQueue会让服务线程在队列为空时, 进行等待, 当有新的消息进入队列后, 自动唤醒服务线程.</p>
<p>ArrayBlockingQueue内部元素都放在一个数组对象中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Object[] items;</div></pre></td></tr></table></figure>
<p>向队列压入元素时可以使用offer()和put()方法. offer()方法, 如果队列已经满了, 会立即返回false.</p>
<p>put()方法将元素压入队列末位, 如果队列满了, 会一直等待, 直到队列有空闲的位置</p>
<p>从队列中弹出元素使用poll()和take()方法. 如果队列为空poll()方法立即返回null. take()方法会等待, 直到队列有可用的元素.</p>
<p>ArrayBlockingQueue内部定义了一些字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ReentrantLock lock;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</div></pre></td></tr></table></figure>
<p>take()操作时, 如果队列为空, 则线程等待在notEmpty上, 新元素入队时, 进行notEmpty上的通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">  lock.lockInterruptibly();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">      notEmpty.await();</div><div class="line">    <span class="keyword">return</span> extract();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>元素入队时的一段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">  items[putIndex] = x;</div><div class="line">  putIndex = inc(putIndex);</div><div class="line">  ++count;</div><div class="line">  notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>put()操作时, 需要让压入线程等待:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">  checkNotNull(e);</div><div class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">  lock.lockInterruptibly();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (count == items.length) </div><div class="line">      notFull.await();</div><div class="line">    insert(e);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当元素被挪走时, 通知等待入队的线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">  E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</div><div class="line">  items[takeIndex] = <span class="keyword">null</span>;</div><div class="line">  takIndex = inc(takeIndex);</div><div class="line">  --count;</div><div class="line">  notFull.signal();</div><div class="line">  <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表(SkipList)"></a>跳表(SkipList)</h3><p>跳表是一种可以快速查找的数据结构, 类似平衡树.</p>
<p>区别: 对平衡树的插入和删除很可能导致平衡树进行一次全局的调整. 而跳表的插入和删除只需要对局部数据进行操作.</p>
<p>在高并发环境下, 需要一个全局锁保证整个平衡树的线程安全. 跳表只需要对部分加锁即可.</p>
<p>跳表的本质是同时维护多个链表, 并且链表是分层的.</p>
<p>最底层的链表维护跳表的所有元素, 每上面一层链表都是下面一层的子集, 一个元素插入到哪些层是完全随机的.</p>
<p>跳表内的所有链表元素都是排序的. 查找时, 可以从顶级链表开始找. 一旦发现查找的元素大于当前链表中的取值, 会转入下一层链表继续查.</p>
<p>使用跳表实现Map和使用哈希算法实现Map的不同: 哈希并不会保存元素的顺序, 而跳表内所有的元素都是有序的.</p>
<p>跳表内使用Node表示一个节点. Node包含两个重要的元素key和value. 每个Node还会指向下一个Node(next元素)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">final</span> K key;</div><div class="line">  <span class="keyword">volatile</span> Object value;</div><div class="line">  <span class="keyword">volatile</span> Node&lt;K, V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对Node的所有操作, 使用CAS方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123; <span class="comment">//设置value的值</span></div><div class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K, V&gt; cmp, Node&lt;K, V&gt; val)</span> </span>&#123; <span class="comment">// 设置next的字段</span></div><div class="line">  <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Index表示索引, 包装了Node, 同时增加了向下的引用和向右的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">final</span> Node&lt;K, V&gt; node;</div><div class="line">  <span class="keyword">final</span> Index&lt;K, V&gt; down;</div><div class="line">  <span class="keyword">volatile</span> Index&lt;K, V&gt; right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个跳表根据Index进行全网的组织</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/17/Java高并发程序设计读书笔记-JDK并发包-线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/17/Java高并发程序设计读书笔记-JDK并发包-线程池/" itemprop="url">
                  Java高并发程序设计读书笔记-JDK并发包-线程池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-17T21:09:56+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线程创建和关闭都需要花费一定得时间</p>
<p>线程本身需要占用内存空间, 大量的线程会抢占内存资源, 可能会导致Out of Memory异常.</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为了避免系统频繁创建和销毁线程, 可以让创建的线程复用.</p>
<p>线程池中总是有几个活跃的线程. 需要使用线程时, 从池中取一个空闲的线程. 工作完成时, 不关闭线程, 将这个线程放回池中. </p>
<h3 id="JDK对线程池的支持"><a href="#JDK对线程池的支持" class="headerlink" title="JDK对线程池的支持"></a>JDK对线程池的支持</h3><p>JDK提供了一套Executor框架, 其本质就是一个线程池.</p>
<p>ThreadPoolExecutor表示一个线程池. Executors类是线程池工厂类. 通过Executor接口, 任何Runnable的对象都可以被ThreadPoolExecutor线程池调度.</p>
<p>Executor主要工厂方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</div></pre></td></tr></table></figure>
<p>以上工厂方法的具体说明:</p>
<ul>
<li>newFixedThreadPool()方法: 返回一个固定线程数量的线程池. 线程池中线程数量始终不变. 有新的任务提交时, 线程池有空闲线程时, 则立即执行; 没有, 则新任务会被暂存在一个任务队列中, 待有空闲线程时, 变处理在任务队列中的任务</li>
<li>newSingleThreadExecutor()方法: 返回一个只有一个线程的线程池, 若对于一个任务被提交, 任务会被保存在任务队列中, 等线程空闲, 按先入先出的顺序执行队列中的任务</li>
<li>newCachedThreadPool()方法: 返回一个根据实际情况调整线程数量的线程池, 线程数量不确定, 有空闲线程可以复用时, 会优先使用可复用的线程. 如果所有线程都在工作, 又有新任务提交, 则创建新线程处理任务.</li>
<li>newSingleThreadScheduledExecutor()方法: 返回一个ScheduledExecutorService对象, 线程池大小为1. ScheduledExecutorService接口在ExecutorService接口上扩展了在给定时间执行某任务的功能, 如在某个固定的延时之后执行, 或周期性执行任务.</li>
<li>newScheduledThreadPool()方法: 也返回一个ScheduledExecutorService对象, 但可以执行线程池中线程数量.</li>
</ul>
<h4 id="固定大小的线程池"><a href="#固定大小的线程池" class="headerlink" title="固定大小的线程池"></a>固定大小的线程池</h4><p>newFixedThreadPool简单示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPoolDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(System.currentTimeMillis() + <span class="string">": Thread ID: "</span> + Thread.currentThread().getId());</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyTask task = <span class="keyword">new</span> MyTask();</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">            executorService.submit(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="不确定数量的线程池"><a href="#不确定数量的线程池" class="headerlink" title="不确定数量的线程池"></a>不确定数量的线程池</h4><p>newCachedThreadPool简单示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPoolDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(System.currentTimeMillis() + <span class="string">": Thread ID: "</span> + Thread.currentThread().getId());</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyTask task = <span class="keyword">new</span> MyTask();</div><div class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">            executorService.submit(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>newSingleThreadScheduledExecutor()方法返回一个ScheduledExecutorService对象, 可以根据时间需要对线程进行调度. 主要有以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);</div><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit);</div><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit);</div></pre></td></tr></table></figure>
<p>ScheduledExecutorService不一定会立即执行任务, 它其实祈祷计划任务的作用. 它会在指定的时间, 对任务进行调度.</p>
<p>schedule()方法会在给定的时间, 对任务进行一次调度.</p>
<p>scheduleAtFixedRate()和scheduleWithFixedDelay()方法会对任务进行周期性调度.</p>
<p>scheduleAtFixedRate()方法, 任务调动频率时固定的, 以上一个任务开始执行时间为起点, 之后的period时间, 调度下一次任务.</p>
<p>scheduleWithFixedDelay()方法则在上一个任务结束后, 再经过delay时间进行任务调度.</p>
<p>如果任务抛出异常, 那后续的所有执行都会被中断.</p>
<h3 id="核心线程池的内部实现"><a href="#核心线程池的内部实现" class="headerlink" title="核心线程池的内部实现"></a>核心线程池的内部实现</h3><p>newFixedThreadPool(), newSingleThreadExecutor(), newCachedThreadPool()方法内部都使用ThreadPoolExecutor实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadPoolExecutor最重要的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                              <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                              <span class="keyword">long</span> keepAliveTime,</div><div class="line">                              TimeUnit unit,</div><div class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                              ThreadFactory threadFactory,</div><div class="line">                              RejectedExecutionHandler handler);</div></pre></td></tr></table></figure>
<p>函数参数含义:</p>
<ul>
<li>corePoolSize: 指定线程池中线程数量</li>
<li>maximumPoolSize: 指定线程池中最大线程数量</li>
<li>keepAliveTime: 当前线程池数量超过corePoolSize时, 多余的空闲线程存活时间.  即, 超过corePoolSize的空闲线程, 在多长时间内, 被销毁</li>
<li>unit: keepAliveTime的单位</li>
<li>workQueue任务队列, 被提交但尚未被执行的任务</li>
<li>threadFactory: 线程工程, 用于创建线程, 一般默认即可.</li>
<li>handler: 拒绝策略. 当任务太多来不及处理, 如何拒绝任务</li>
</ul>
<p>workQueue指被提交但未被执行的任务队列, 是一个BlockingQueue接口的对象, 用于存放Runnable对象. 在ThreadPoolExecutor的构造函数中可以使用以下几种BlockingQueue.</p>
<ul>
<li>直接提交的队列: 由SynchronousQueue提供. SynchronousQueue没有容量, 每次插入操作, 都要等待一个删除操作. 每次删除操作都要等待对应的插入操作. 使用SynchronousQueue时, 通常设置很大的maximumPoolSize指, 否则很容易执行拒绝策略</li>
<li>有界的任务队列: 由ArrayBlockingQueue提供. ArrayBlockingQueue的构造函数必须带有一个容量参数.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</div></pre></td></tr></table></figure>
<p>​    有新任务需要执行时, 如果线程池的实际线程数小于corePoolSize, 会优先创建                        新的线程. 如果大于corePoolSize, 会将新的任务加入等待队列. 若队列已满, 无法加入, 在总线程数不大于maximumPoolSize, 创建新的线程执行任务, 若大于maximumPoolSize, 则执行拒绝策略.</p>
<ul>
<li>无界的任务队列: 由LinkedBlickingQueue提供. 除非系统资源耗尽, 否则无界的任务队列不存在任务入队失败的情况. 其他情况和有界队列类似</li>
<li>优先任务队列: 带有执行优先级的队列, 由PriorityBlickingQueue提供. 可以控制任务的执行先后顺序. 属于无界队列</li>
</ul>
<p>ThreadPoolExecutor线程池核心调度代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// workerCountOf获得当前线程池的线程总数, 当线程总数小于corePoolSize时, 通过addWorker方法直接调度执行</span></div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>拒绝策略表示党任务数量超过系统实际承载能力时, 该如何处理. JDK内置提供了四种拒绝策略</p>
<ul>
<li>AbortPolicy策略: 直接抛出异常, 阻止系统正常工作</li>
<li>CallerRunsPolicy策略: 只要线程未关闭, 直接在调用者线程中, 运行当前被丢弃的任务, 这样不会真的丢弃任务, 但任务提交线程的性能极有可能会急剧下降</li>
<li>DiscardOledestPolicy策略: 丢弃最老的一个请求, 也就是即将被执行的一个任务, 并尝试再次提交当前任务</li>
<li>DiscardPolicy策略: 默默丢弃无法处理的任务, 不予任何处理. 如果允许任务丢弃, 这可能是最好的一种方案.</li>
</ul>
<p>内置的策略实现了RejectedExecutionHandler接口, 可以自己扩张RejectedExecutionHandler接口, 实现自己的拒绝策略.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectThreadPoolDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(System.currentTimeMillis() + <span class="string">": Thread ID: "</span> + Thread.currentThread().getId());</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyTask task = <span class="keyword">new</span> MyTask();</div><div class="line"></div><div class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>,</div><div class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">10</span>),</div><div class="line">                Executors.defaultThreadFactory(), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</div><div class="line">                System.out.println(r.toString() + <span class="string">" is discard"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Integer.MAX_VALUE; i++) &#123;</div><div class="line">            executorService.submit(task);</div><div class="line">            Thread.sleep(<span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义线程创建"><a href="#自定义线程创建" class="headerlink" title="自定义线程创建"></a>自定义线程创建</h3><p>ThreadFactory是一个接口, 只有一个方法, 用来创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</div></pre></td></tr></table></figure>
<p>线程池创建线程就是调用这个方法.</p>
<p>自定义线程池有以下好处:</p>
<ol>
<li>可以跟踪线程池在何时床创建了多少线程</li>
<li>可以自定义线程名称, 组, 优先级</li>
<li>可以吧线程设置为守护线程</li>
</ol>
<p>ThreadFactory简单示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFactoryDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(System.currentTimeMillis() + <span class="string">": Thread ID: "</span> + Thread.currentThread().getId());</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyTask task = <span class="keyword">new</span> MyTask();</div><div class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>,</div><div class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),</div><div class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">                        Thread t = <span class="keyword">new</span> Thread(r);</div><div class="line">                        t.setDaemon(<span class="keyword">true</span>);</div><div class="line">                        System.out.println(<span class="string">"create "</span> + t);</div><div class="line">                        <span class="keyword">return</span> t;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">            executorService.submit(task);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">2000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="扩张线程池"><a href="#扩张线程池" class="headerlink" title="扩张线程池"></a>扩张线程池</h3><p>ThreadPoolExecutor是一个可以扩展的线程池. 它提供了beforeExecute(), afterExecute(), terminated()三个接口对线程池进行控制.</p>
<p>ThreadPoolExecutor.Worker是ThreadPoolExecutor的内部类, 它实现了Runnable接口, ThreadPoolExecutor线程池的工作线程也正是Worker实例. Worker.runTask方法被线程池以多线程模式异步调用.</p>
<p>扩张线程池示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPool</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"正在执行: Thread ID: "</span> + Thread.currentThread().getId() + <span class="string">", Task Name="</span> + name);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;()) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"准备执行: "</span> + ((MyTask) r).name);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"执行完成: "</span> + ((MyTask) r).name);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"线程池退出"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">            MyTask task = <span class="keyword">new</span> MyTask(<span class="string">"Task-Geym-"</span> + i);</div><div class="line">            es.execute(task);</div><div class="line">            Thread.sleep(<span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">// shutdown()方法不会立即终止所有任务, 会等待所有任务执行完成后再关闭线程池</span></div><div class="line">        es.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优化线程池线程数量"><a href="#优化线程池线程数量" class="headerlink" title="优化线程池线程数量"></a>优化线程池线程数量</h3><p>线程池的大小对系统的性能有一定的影响. 过大或者过小的线程数量都无法发挥最有的系统性能, 但是线程池大小的确定也不需要做到非常精确. 只要避免极大和极小两种情况, 线程池的大小对系统性能的影响并不大. 确定线程池大小需要考虑CPU数量, 内存大小等因素. 估计线程池大小的经验公式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Ncpu = CPU数量</div><div class="line">Ucpu = 目标CPU使用率, 0 &lt;= Ucpu &lt;= 1</div><div class="line">W/C = 等待时间和计算时间的比率</div><div class="line">为保持处理器达到期望的使用率, 最优的池大小等于:</div><div class="line">Nthreads = Ncpu * Ucpu * (1 + W/C)</div><div class="line">在Java中, 通过:</div><div class="line">Runtime.getRuntime().availableProcessors();</div><div class="line">获取可以CPU数量</div></pre></td></tr></table></figure>
<h3 id="线程池中的堆栈"><a href="#线程池中的堆栈" class="headerlink" title="线程池中的堆栈"></a>线程池中的堆栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTrace</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a, b;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.a = a;</div><div class="line">            <span class="keyword">this</span>.b = b;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">double</span> re = a/b;</div><div class="line">            System.out.println(re);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TraceThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line">                                       <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">            <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.execute(wrap(command, clientTrace(), Thread.currentThread().getName()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"Client stack trace"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String threadName)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        task.run();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        clientStack.printStackTrace();</div><div class="line">                        <span class="keyword">throw</span>  e;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ThreadPoolExecutor pools = <span class="keyword">new</span> TraceThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">            pools.execute(<span class="keyword">new</span> DivTask(<span class="number">100</span>,i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>“分而治之”是一个非常有效的处理大量数据的方法. 例如: 需要处理1000个数据, 可以先处理其中10个, 然后, 分阶段处理100次, 将100次的结果进行合成, 就是最终想要的对原始1000个数据的处理结果.</p>
<p>JDK中, 给出一个ForKoinPoo线程池, 服役fork()方法并不急着开启线程, 而是提交给ForkJoinPool线程池处理, 以节省系统资源.</p>
<p>如果遇到以下情况: 线程A已经把任务处理完了, 而线程B还有一堆任务未处理, 此时, 线程A会帮助线程B, 从线程B的任务队列中的<strong>底部</strong>拿任务处理. 而线程B继续从任务队列的<strong>顶部</strong>开始拿任务处理.</p>
<p>ForkJoinTask有两个重要的子类, RecursiveAction, RecursiveTas, 分别代表没有返回值的任务和可以携带返回值的任务.</p>
<p>Fork/Join框架的使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line"><span class="comment">// 任务分解规模, 如果需要求和的总数大于THRESHOLD, 那么任务需要再次分解</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.start = start;</div><div class="line">        <span class="keyword">this</span>.end = end;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> canCompute = (end-start)&lt;THRESHOLD;</div><div class="line">        <span class="keyword">if</span> (canCompute) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i=sum; i&lt;=end; i++) &#123;</div><div class="line">                sum += i;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 分成100个小任务</span></div><div class="line">            <span class="keyword">long</span> step = (start+end)/<span class="number">100</span>;</div><div class="line">            ArrayList&lt;CountTask&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">long</span> pos = start;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">                <span class="keyword">long</span> lastOne = pos + step;</div><div class="line">                <span class="keyword">if</span> (lastOne &gt; end)</div><div class="line">                    lastOne = end;</div><div class="line">                CountTask subTask = <span class="keyword">new</span> CountTask(pos, lastOne);</div><div class="line">                pos += step + <span class="number">1</span>;</div><div class="line">                subTasks.add(subTask);</div><div class="line">                subTask.fork();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (CountTask t : subTasks) &#123;</div><div class="line">                sum += t.join();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</div><div class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">0</span>, <span class="number">200000L</span>);</div><div class="line">        ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">long</span> res = result.get();</div><div class="line">            System.out.println(<span class="string">"sum="</span> + res);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用ForkJoin需要注意, 任务的划分层次很深, 一直得不到返回, 可能会发生两种情况:</p>
<ul>
<li>系统内的线程数量越积越多, 导致性能下降</li>
<li>函数调用层次变得很深, 导致栈溢出</li>
</ul>
<p>ForkJoin线程池使用无锁的栈来管理线程. 如果一个工作线程暂时取不到可用的任务, 可能会被挂起, 挂起的线程会被压入由线程池维护的栈中. 等将来有任务可用时, 再唤醒栈中的这些线程.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/16/Java高并发程序设计读书笔记-JDK并发包-线程阻塞工具类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/16/Java高并发程序设计读书笔记-JDK并发包-线程阻塞工具类/" itemprop="url">
                  Java高并发程序设计读书笔记-JDK并发包-线程阻塞工具类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-16T22:25:39+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LockSuport 是一个方便使用的线程阻塞工具, 可以在线程内的任意位置让线程阻塞. 和Thread.suspend()相比, 它弥补了由于resume()在前发生, 导致线程无法继续执行的情况.</p>
<p>和Object.wait()相比, 它不需要获得某个对象的锁, 也不会抛出InterruptedException异常.</p>
<p>LockSupport的静态方法park()方法可以阻塞当前线程. parkNanos(),parkUtil()方法, 实现了限时等待.</p>
<p>用LockSupport解决resume()在前发生的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</div><div class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.setName(name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (u) &#123;</div><div class="line">                System.out.println(<span class="string">"in "</span> + getName());</div><div class="line">                LockSupport.park();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        t1.start();</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">        t2.start();</div><div class="line">        LockSupport.unpark(t1);</div><div class="line">        LockSupport.unpark(t2);</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然还是无法保证unpark()方法发生在park()方法之后, 但是这段代码总是能正常结束.</p>
<p>LockSupport类使用类似信号量机制. 它为每个线程准备一个许可, 如果许可可用, 那么park()函数会立即返回, 并消费这个许可. 如果许可不可用, 就会阻塞.</p>
<p>unpark()方法使得一个许可变成可用. 但是许可不能累加, 永远只能有一个许可.</p>
<p>LockSupport.park()还支持中断影响. 和其他接受中断的函数不同, LockSupport.park()不会抛出InterruptedException异常, 只会默默的返回.</p>
<p>可用从Thread.interrupted()等方法获取中断标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportIntDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</div><div class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.setName(name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (u) &#123;</div><div class="line">                System.out.println(<span class="string">"in "</span>+ getName());</div><div class="line">                LockSupport.park();</div><div class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                    System.out.println(getName() + <span class="string">" 被中断了"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(getName() + <span class="string">"执行结束"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        t1.start();</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">        t2.start();</div><div class="line">        t1.interrupt();</div><div class="line">        LockSupport.unpark(t2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/16/Java高并发程序设计读书笔记-JDK并发包-循环栅栏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/16/Java高并发程序设计读书笔记-JDK并发包-循环栅栏/" itemprop="url">
                  Java高并发程序设计读书笔记-JDK并发包-循环栅栏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-16T21:49:46+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CyclicBarrier是一种多线程并发控制工具. 和CountDownLatch类似, 可以实现线程间的计数等待.</p>
<p>CyclicBarrier表示循环栅栏, 这里的栅栏用来阻止线程继续执行, 要求线程在栅栏处等待. 这个计数器可以反复使用.</p>
<p>如果将计数器设置为10, 那么凑齐第一批10个线程后, 计数器归零, 然后接着凑齐下一批10个线程.</p>
<p>CyclicBarrier的构造函数接受一个参数作为barrierAction, 即当计数器一次计数完成后, 系统会执行的动作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span>;</div></pre></td></tr></table></figure>
<p>CyclicBarrier简单示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String soldier;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;</div><div class="line"></div><div class="line">        Soldier (CyclicBarrier cyclic, String soldierName) &#123;</div><div class="line">            <span class="keyword">this</span>.cyclic = cyclic;</div><div class="line">            <span class="keyword">this</span>.soldier = soldierName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">// 等待士兵到齐</span></div><div class="line">                cyclic.await();</div><div class="line">                doWork();</div><div class="line">              <span class="comment">// 等待士兵完成任务</span></div><div class="line">                cyclic.await();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt()%<span class="number">10000</span>));</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(soldier + <span class="string">": 完成任务"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        <span class="keyword">int</span> N;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.flag = flag;</div><div class="line">            <span class="keyword">this</span>.N = N;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (flag) &#123;</div><div class="line">                System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个, 任务完成!"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个, 集合完毕!"</span>);</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</div><div class="line">        Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">      <span class="comment">// 将计数器设置为10, 并要求在计数器达到指标时, 执行BarrierRun的run方法</span></div><div class="line">        CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"集合队伍!"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报道!"</span>);</div><div class="line">            allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span>+i));</div><div class="line">            allSoldier[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/16/Java高并发程序设计读书笔记-JDK并发包-倒计时器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/16/Java高并发程序设计读书笔记-JDK并发包-倒计时器/" itemprop="url">
                  Java高并发程序设计读书笔记-JDK并发包-倒计时器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-16T21:35:49+08:00">
                2017-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CountDownLatch是一个非常实用的多线程控制工具类. 通常用来控制线程等待, 可以让某一个线程等待知道倒计时结束, 再执行.</p>
<p>CountDownLatch的构造函数接受一个整数作为参数, 即当前这个计数器的计数个数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</div></pre></td></tr></table></figure>
<p>简单示例: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLacthDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// 表示需要10个线程完成任务</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLacthDemo demo = <span class="keyword">new</span> CountDownLacthDemo();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</div><div class="line">            System.out.println(<span class="string">"check complete"</span>);</div><div class="line">            <span class="comment">// 通知CountDownLatch, 一个线程已经完成工作. 倒计时器可以减1了</span></div><div class="line">            end.countDown();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</div><div class="line">            executorService.submit(demo);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 要求主线程等待10个任务全部完成后, 主线程才能继续执行</span></div><div class="line">        end.await();</div><div class="line">        System.out.println(<span class="string">"Fire!"</span>);</div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://singthi4079.github.io/2017/10/12/Java高并发程序设计读书笔记-JDK并发包-读写锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Blue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blue的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/12/Java高并发程序设计读书笔记-JDK并发包-读写锁/" itemprop="url">
                  Java高并发程序设计读书笔记-JDK并发包-读写锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-12T22:27:20+08:00">
                2017-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ReadWriteLock是JDK5提供的读写分离锁. 读写分离锁可以有效的减少锁竞争, 提升性能.</p>
<p>读写锁允许多个线程同时读, 写写操作和读写操作相互等待和持有锁.</p>
<p>读写锁访问约束情况</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">读</th>
<th style="text-align:center">写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td style="text-align:center">非阻塞</td>
<td style="text-align:center">阻塞</td>
</tr>
<tr>
<td>写</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">阻塞</td>
</tr>
</tbody>
</table>
<p>使用读写锁示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock(); <span class="comment">// 模拟读操作</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 读操作耗时越多, 读写锁优势就越明显</span></div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();<span class="comment">// 模拟写操作</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            value = index;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</div><div class="line"></div><div class="line">        Runnable readRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    demo.handleRead(readLock);</div><div class="line">                    demo.handleRead(lock);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Runnable writeRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    demo.handleWrite(writeLock, <span class="keyword">new</span> Random().nextInt());</div><div class="line">                    demo.handleWrite(lock, <span class="keyword">new</span> Random().nextInt());</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Blue" />
          <p class="site-author-name" itemprop="name">Blue</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Blue</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
