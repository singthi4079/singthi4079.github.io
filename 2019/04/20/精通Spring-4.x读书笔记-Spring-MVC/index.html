<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Blue">
  <!-- Open Graph Data -->
  <meta property="og:title" content="精通Spring 4.x读书笔记-Spring MVC">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="Blue的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://singthi4079.github.ioundefined">
  
    <link rel="alternate" href="/atom.xml" title="Blue的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Blue的博客</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">精通Spring 4.x读书笔记-Spring MVC</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Blue</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-04-20</span>
            <span class="time">18:08:45</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Spring/">#Spring</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="Spring-MVC体系概述"><a href="#Spring-MVC体系概述" class="headerlink" title="Spring MVC体系概述"></a>Spring MVC体系概述</h3><p>DispatcherServlet负责截获请求并将其分派给相应的处理器处理. Spring MVC框架包括注解驱动控制器, 请求及响应的信息处理, 视图解析, 本地化解析, 上传文件解析, 异常处理及表单标签绑定等内容</p>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/SpringMVC框架模型.png" alt="SpringMVC框架模型"></p>
<p>Spring MVC处理请求的整体过程:</p>
<ol>
<li>客户端发出一个HTTP请求, Web应用服务器接收到请求, 如果匹配DispatcherServlet的请求映射路径(web.xml指定), 则Web容器将该请求转交给DispatcherServlet处理</li>
<li>DispatcherServlet接收到这个请求后, 根据请求的信息(包括URL, HTTP方法, 请求报文头, 请求参数, Cookie等)及HandlerMapping的配置找到处理请求的处理器(Handler). 可将HandlerMapping看作路由控制器, 将Handler看作目标主机. 任何Object都可以称为请求处理器</li>
<li>DispatcherServlet根据HandlerMapping得到对应当前请求的Handler后, 通过HandlerAdapter对Handler进行封装, 再以统一的适配器接口调用Handler. HandlerAdapter用统一的接口对各个Handler方法进行调用</li>
<li>处理器完成业务逻辑的处理后返回一个ModelAndView给DispatcherServlet, ModelAndView包含视图逻辑名和模型数据信息</li>
<li>ModelAndView包含的是”逻辑视图名”而非真正的视图对象, DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作</li>
<li>得到真实的视图对象View后, DispatcherServlet使用这个View对象对ModelAndView中的模型数据进行视图渲染</li>
<li>最终客户端得到的响应信息可能是一个普通的HTML也没, 也可能是XML或JSON串, 甚至是一张图片或一个PDF文档</li>
</ol>
<h4 id="配置DispatcherServlet"><a href="#配置DispatcherServlet" class="headerlink" title="配置DispatcherServlet"></a>配置DispatcherServlet</h4><p>1) DispatcherServlet框架如何截获特定的HTTP请求并交由Spring MVC框架处理?</p>
<p>2) 位于Web层的Spring容器(WebApplicationContext)如何与位于业务层的Spring容器(ApplicationContext)建立关联, 以使Web层的Bean可以调用业务层的Bean?</p>
<p>3) 如何初始化Spring MVC的各个组件, 并将它们装配到DispatcherServlet中</p>
<ol>
<li><p>配置DispatcherServlet, 截获特定的URL请求</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 业务层和持久层的Spring配置文件, 这些配置文件被父Spring容器所使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.context.ContextLoaderListener</span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 名为DispatcherServlet匹配的URL模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ContexntLoaderListener是一个ServletContextListener, 它通过contextConfigLocation参数所指定的Spring配置文件启动”业务层”的Spring容器.</p>
<p>这里Web层容器作为业务层容器的子容器, Web层容器就可以引用业务层容器中的Bean, 业务层容器不能引用Web层容器的Bean</p>
<p>一个web.xml可以配置多个DispatcherServlet, 通过<code>&lt;servlet-mapping&gt;</code>配置, 让每个DispatcherServlet处理不同的请求</p>
<p>以下是常用的配置参数, 通过<servlet>的<init-param>指定</init-param></servlet></p>
<ul>
<li>namespace: DispatcherServelt对应的命名空间, 默认为<servlet-name>-servlet, 用于构造Spring配置文件的路径, 显式指定该属性后, 配置文件对应的路径为WEB-INF/<namespace>.xml.</namespace></servlet-name></li>
<li>contextConfigLocation: 如果DispatcherServlet上下文对应的Spring配置文件有多个, 可以使用该属性按照Spring资源路径的方式指定.</li>
<li>publishContext: 布尔类型的属性, 默认为true. DispatcherServlet根据该属性决定是否将WebApplicationContext发布到ServletContext的属性列表中, 以便调用者可以借由ServletContext找到WebApplicationContext实例. 对应的属性名为DispatcherServlet#getServletContextAttributeName()方法返回</li>
<li>publishEvents: 布尔类型的属性. DispatcherServlet处理完一个请求后, 是否需要向容器发布一个ServletRequestHandledEvent事件, 默认为true.如果容器中没有任何事件监听器, 可以将该属性设置为false, 以便提高运行性能.</li>
</ul>
<p>显式指定Web层的配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">      /WEB-INF/spring/webApplicationContext.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Servlet 3.0环境中, 可以使用编程的方式来配置Servlet容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">    ServletRegistration.Dynamic.registratiion = container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet());</span><br><span class="line">    registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    registration.addMapping(<span class="string">"*.html*"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Servlet 3.0环境中, 容器回再类路径中查找实现ServletContainerInitializer的类, 如果发现已有实现类, 就会调用它来配置Servlet容器. Spring中, SpringServletContainerInitializer类实现了该接口, 同时这个类又会查找实现WebApplicationInitializer接口的类, 并将配置任务交给这个实现类去完成.</p>
<p>Spring 提供了一个便利的抽象类AbstractAnnotationConfigDispatcherServletInitializer来实现这个接口, 使得它在注册DispatcherServlet时只需简单的指定它的Servlet映射即可</p>
</li>
<li><p>探究DispatcherServlet的内部逻辑</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化上传文件解析器</span></span><br><span class="line">  initMultipartResolver();</span><br><span class="line">  <span class="comment">//初始化本地化解析器</span></span><br><span class="line">  initLocaleResolver();</span><br><span class="line">  <span class="comment">// 初始化主题解析器</span></span><br><span class="line">  initThemeResolver();</span><br><span class="line">  <span class="comment">// 初始化处理器映射器</span></span><br><span class="line">  initHandlerMappings();</span><br><span class="line">  <span class="comment">// 初始化处理器适配器</span></span><br><span class="line">  initHandlerAdapters();</span><br><span class="line">  <span class="comment">// 初始化处理器异常解析器</span></span><br><span class="line">  initHandlerExceptionResolvers();</span><br><span class="line">  <span class="comment">// 初始化请求到视图名翻译器</span></span><br><span class="line">  initRequestToViewNameTranslator();</span><br><span class="line">  <span class="comment">// 初始化视图解析器</span></span><br><span class="line">  initViewResolvers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initStrategies()方法将在WebApplicationContext初始化后自动执行, 此时Spring上下文中的Bean已经初始化完毕.</p>
<p>该方法的工作原理: 通过反射机制查找并装配Spring容器中用户显示自定义的组件Bean, 如果没有找到, 则装配默认的组件实例.</p>
<p>在org/springframework/web/servlet类路径下有一个DispatcherServlet.properties配置文件, 指定了DispatcherServlet所使用的默认组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 本地化解析器</span><br><span class="line">org.springframework.web.servlet.LocalResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocalResolver</span><br><span class="line"># 主题解析器</span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"># 处理器映射</span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><span class="line"></span><br><span class="line"># 处理器适配器</span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandleradapter,\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter, \ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span><br><span class="line"></span><br><span class="line"># 异常处理器</span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver, \ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver, \ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line"># 视图名称翻译器</span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line"># 视图解析器</span><br><span class="line">org.springframework.web.servlet.ViewSolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br></pre></td></tr></table></figure>
<p>DispatcherServlet装配每种组件的过程</p>
<p>|     组件类型     |                           发现机制                           |<br>| :————–: | :———————————————————-: |<br>|  文件上传解析器  | 1) 查找名为multipartResolver, 类型为MultipartResolver的Bean作为该类型的组件<br>2) 没有默认实现类<br>没有在上下文中显示定义这一类型的组件, DispatcherServlet中将不会拥有该类型的组件 |<br>|   本地化解析器   | 1) 查找名为localeResolver, 类型为LocaleResolver的Bean作为该类型的组件<br>2) 找不到, 使用默认的实现类(AcceptHeaderLocaleResolver)创建该类型的组件 |<br>|    主题解析器    | 1) 查找名为themeResolver, 类型为LocaleResolver的Bean作为该类型的组件<br>2) 找不到则使用默认的实现类(FixedThemeResolver)创建该类型的组件 |<br>|   处理器映射器   | 1) 如果detectAllHandlerMappings属性为true(默认为true), 根据类型匹配机制查找上下文及父Spring容器中所有类型为HandlerMapping的Bean, 将它们作为该类型的组件<br>2) 如果detectAllHandlerMappings属性为false, 查找名为handlerMapping, 类型为HandlerMapping的Bean作为该类型的组件<br>3) 如果都找不到, 则使用BeanNameUrlHandlerMapping实现类创建该类型的组件 |<br>|   处理器适配器   | 1) 如果detectAllHandlerAdapters属性为true(默认为true), 根据类型匹配机制查找上下文及父Spring容器中所有类型为HandlerAdapter的Bean, 将它们作为该类型的组件<br>2) 如果detectAllHandlerAdapters属性为false, 查找名为handlerAdapter, 类型为HandlerAdapter的Bean作为该类型的组件<br>3) 都找不到, 使用DispatcherServlet.properties配置文件中指定的3个实现类分别创建一个适配器, 并添加到适配器列表中 |<br>| 处理器异常解析器 | 1) 如果detectAllHandlerExceptionResolvers属性为true(默认为true), 根据类型匹配(HandlerExceptionResolver)机制查找上下文及父Spring容器中所有匹配的Bean作为该类型的组件<br>2) 如果detectAllHandlerExceptionResolvers属性为false, 查找名为handlerExceptinResolver, 类型为HandlerExceptionResolver的Bean作为该类型的组件<br>3) 都找不到, 查找DispatcherServlet.properties中定义的默认实现类, 该文件中没有对应的处理器异常解析器的more实现类 |<br>|   视图名翻译器   | 1) 查找名为viewNameTranslator, 类型为RequestToVeiwNameTranslator的Bean作为该类型的组件<br>2) 找不到, 使用默认的实现类DefaultRequestToViewNameTranslator创建该类型组件 |<br>|    视图解析器    | 1) detectAllViewResolvers属性为true(默认为true), 根据类型匹配ViewResolver机制查找上下文及父Spring容器中所有匹配的Bean作为该类型的组件<br>2) detectAllViewResolvers属性为false, 查找名为viewResolver, 类型为ViewResolver的Bean作为该类型的组件<br>3) 都找不到, 通过DispatcherServlet.properties中定义的默认实现类(InternalResourceViewResolver)创建该类型的组件 |</p>
</li>
</ol>
<p>Spring MVC应用开发一般包括以下几个步骤:</p>
<p>1) 配置web.xml, 指定业务层对应的Spring配置文件, 定义DispatcherServlet</p>
<p>2) 编写处理请求的控制权(处理器)</p>
<p>3) 编写视图对象</p>
<p>4) 配置Spring MVC配置文件, 使控制器, 视图解析器等生效</p>
<h3 id="注解驱动的控制器"><a href="#注解驱动的控制器" class="headerlink" title="注解驱动的控制器"></a>注解驱动的控制器</h3><h4 id="使用-RequestMapping映射请求"><a href="#使用-RequestMapping映射请求" class="headerlink" title="使用@RequestMapping映射请求"></a>使用@RequestMapping映射请求</h4><p>在POJO类定义处标注@Controller, 再通过<code>&lt;content:component-scan&gt;</code>扫描相应的类包, 即可使POJO成为一个能处理HTTP请求的控制器</p>
<p>在控制器的类定义及方法定义处都可以标注@RequestMapping, 类定义处的@RequestMapping提供初步的请求映射信息, 方法定义处的@RequestMapping提供进一步的细分映射信息</p>
<p>DispatcherServlet截获请求后, 通过控制器上@RequestMapping提供的映射信息确定请求所对应的处理方法</p>
<p>将请求映射到控制器处理方法的工作包含一系列映射规则:</p>
<ol>
<li><p>通过请求URL进行映射</p>
<p>@RequestMapping使用value指定请求URL, 如: @RequestMapping(“/user”). </p>
<p>通过@PathVariable可以将URL中的占位符参数绑定到控制器处理方法的入参中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showDetail</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URL中的<code>{xxx}</code>占位符通过<code>@PathVariable(&quot;xxx&quot;)</code>绑定到操作方法的入参中.</p>
<p>类定义处@RequestMapping的URL如果使用占位符的参数, 也可以绑定到处理方法的入参中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RelativePathUriTemplateController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/ptes/&#123;petId&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String ownId, @PathVariable String petId, Model model)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   默认情况下, Java类的反射对象并未包含方法入参的名称, 在Java 8.0中可以通过javac -parameters生成方法入参的元数据信息, 低版本的Java通过javac -g打开生成所有调试信息的开发. 在Maven中可以显示配置maven-compiler-plugin编译插件, 开启编译输出调试信息的开关</p>
<p>   @PathVariable最好显示指定绑定的参数名, 避免因编译方式不同造成参数绑定失败</p>
<ol start="2">
<li><p>通过请求参数, 请求方法或请求头进行映射</p>
<p>一个标准的HTTP请求报文</p>
<p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/HTTP请求报文.png" alt="HTTP请求报文"></p>
<p>1) 请求方法, 包括GET, POST, DELETE, HEAD, OPTIONS, PUT, TRACE. Spring提供了HiddenHttpMethodFilter, 运行通过<code>_method</code>表单参数指定这些特殊的HTTP方法(实际上还是通过POST提交表单). 服务器短配置了HiddenHttpMethodFilter后, Spring会根据<code>_method</code>参数指定的值模拟出相应的HTTP方法</p>
<p>2) 请求对应的URL, 它和报文头的Host属性组成完整的请求URL</p>
<p>3) 协议名称和版本号</p>
<p>4) HTTP的报文头, 包含若干属性, 格式为”属性名: 属性值”, 服务器根据此获取客户端的信息</p>
<p>5) 报文体, 将一个页面表单中的组件值通过param1=value&amp;param2=value2的键值对形式编码成一个格式化串, 承载多个请求参数的数据</p>
<p>@RequestMapping还可以使用请求方法, 请求头参数及请求参数(报文体和URL包含的请求参数)映射请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用请求方法及请求参数映射请求</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/delete"</span>, method=RequestMethod.POST, params=<span class="string">"userId"</span>)</span><br><span class="line"><span class="comment">//使用报文头映射请求</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/show"</span>, headers=<span class="string">"content-type=text/*"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="请求处理方法签名"><a href="#请求处理方法签名" class="headerlink" title="请求处理方法签名"></a>请求处理方法签名</h4><ol>
<li><p>使用@RequestParam绑定请求参数值</p>
<p>Java类反射对象默认不记录方法入参的名称, 需要在方法入参处使用@RequestParam注解指定器对应的请求参数. </p>
<p>有以下三个参数:</p>
<ul>
<li>value: 参数名</li>
<li>required: 是否必须, 默认为true, 请求中必须包含对应的参数名, 不存在则抛出异常</li>
<li>defaultValue: 默认参数值, 设置该参数, 自动将required设为false</li>
</ul>
</li>
<li><p>使用@CookieValue绑定请求中的Cookie值</p>
<p>和@RequestParam拥有3个一样的参数</p>
</li>
<li><p>使用@RequestHeader绑定请求报文头的属性值</p>
<p>请求报文包含若干个报文头属性， 服务器可以根据此获知客户端信息, 通过@RequestHeader即可将报文头属性绑定到处理方法的入参中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handler</span><span class="params">(@RequestHeader(<span class="string">"Accept-Encoding"</span>)</span> Stirng encoding, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"Keep-Alive"</span>)</span> <span class="keyword">long</span> keepAlive)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命令/表单对象绑定请求参数</p>
<p>命令/表单对象不需要实现任何借口, 拥有若干属性的POJO.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(User user)</span></span></span><br></pre></td></tr></table></figure>
<p>User就是一个命令/表单对象. Spring MVC会按请求参数名和命令/表单对象对象属性名匹配的方式, 自动为该对象填充属性值. 支持级联的属性名, 如: dept.deptId</p>
</li>
<li><p>使用Servlet API对象作为入参</p>
<p>使用HttpServletRequest, HttpServletResponse, HttpSession作为入参, Spring MVC会自动将Web层对应的Servlet对象传递给处理方法的入参.</p>
<p>如果处理方法自行使用HttpServletResponse返回响应, 则处理方法的返回设置为void即可</p>
</li>
<li><p>使用I/O对象作为入参</p>
<p>Servlet的ServletRequest拥有getInputStream()和getReader()方法, 通过它们读取请求的信息. ServletResponse拥有getOutputStream()和getWriter()方法, 通过它们输出响应信息</p>
<p>控制器的处理方法可以使用InputStream/Reader及OutputStream/Writer作为方法的入参, Spring MVC将获取ServletRequest的InputStrema/Reader或ServletResponse的OutputStream/Writer, 传递给处理方法</p>
</li>
</ol>
<h4 id="使用HttpMessageConverter-lt-T-gt"><a href="#使用HttpMessageConverter-lt-T-gt" class="headerlink" title="使用HttpMessageConverter&lt;T&gt;"></a>使用<code>HttpMessageConverter&lt;T&gt;</code></h4><p>负责将请求信息转换为一个对象类型为T, 将对象输出为响应信息</p>
<p>HttpMessageConverter有RequestMappingHandlerAdapter使用, 将请求信息对象转换为对象, 或将对象转换为响应信息</p>
<p>定义了以下几个方法:</p>
<ul>
<li>Boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType): 指定转换器可以读取的对象类型, 即转换器可将请求信息转换为clazz类型的对象; 同时指定支持的MIME每天类型(text/html, aplication/json等)</li>
<li>Boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType): 指定转换器可以将clazz类型的对象写到响应流中, 响应流支持的没定类型在mediaType定义</li>
<li><code>List&lt;MediaType&gt; getSupportedMediaTypes()</code>: 该转换器支持的媒体类型</li>
<li>T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage): 将请求信息流转换为T类型的对象</li>
<li>void write(T t, MediaType contentType, HttpOutputMessage outputMessage): 将T类型的对象写到响应流中, 同时指定响应的媒体类型</li>
</ul>
<ol>
<li><p><code>HttpMessageConverter&lt;T&gt;</code>的实现类</p>
<p>| 实现类                                  | 功能说明                                                     |<br>| ————————————— | ———————————————————— |<br>| StringHttpMessageConverter              | 将请求信息转为字符串<br>1) T为String类型<br>2) 可读取所有媒体类型, 可通过设置supportedMediaTypes属性指定媒体类型<br>3) 响应信息的媒体类型为text/plain |<br>| FormHttpMessageConverter                | 将表单数据读取到MultiValueMap中<br>1) T为MultiValueMap&lt;String, ?&gt;类型<br>2) 支持读取<code>application/x-www-form-urlencoded</code>的媒体类型, 不支持<code>multipart/form-data</code>的媒体类型<br>3) 可写<code>application/x-www-form-urlencoded</code>及<code>multipart/form-data</code>媒体类型的响应信息 |<br>| AllEncompassingFormHttpMessageConverter | 扩展了FormHttpMessageConverter, 如果部分表单属性是XML数据, 则可用该转换器进行读取 |<br>| ResourceHttpMessageConverter            | 读/写Resource对象<br>1) T为Resource类型<br>2) 可读取所有媒体类型的请求<br>3) 如果类路径下提供JAF(Java Activation Framework), 根据Resource的类型指定响应的媒体类型, 否则响应的媒体类型为<code>application/octet-stream</code> |<br>| BufferedImageHttpMessageConverter       | 读/写BufferedImage对象<br>1) T为BufferedImage类型<br>2) 读取所有媒体类型<br>3) 返回BufferedImage响应的媒体类型, 可以通过contextType显式指定 |<br>| ByteArrayHttpMessageConverter           | 读写二进制数据<br>1) T为byte[]类型<br>2) 读取所有媒体类型的请求, 同设置supportedMediaTypes属性指定媒体类型<br>3) 响应信息媒体类型为<code>application/octet-stream</code> |<br>| SourceHttpMessageConverter              | 读写java.xml.transform.Source类型的数据<br>1) T为Source及其扩展类<br>2） 读取text/xml和application/xml媒体类型的请求<br>3) 响应信息的媒体类型为text/xml或application/xml |<br>| MarshallingHttpMessageConverter         | 通过Marshaller和Unmarshaller读写XML信息<br>1) T为Object类型<br>2) 读取text/xml和application/xml媒体类型的请求<br>3) 响应信息的媒体类型为text/xml或application/xml |<br>| Jaxb2RootElementHttpMessageConverter    | 通过JAXB2度下XML信息, 并将请求信息转换到标注XmlRootElement和XmlType注解的类中<br>1) T为Object类型<br>2) 读取text/xml和application/xml媒体类型的请求<br>3) 响应信息的媒体类型为text/xml或application/xml |<br>| MappingJackson2HttpMessageConverter     | 利用Jackson的ObjectMapper读写JSON数据<br>1) T为Object类型<br>2) 读取application/json媒体类型的请求<br>3) 响应信息的媒体类型为application/json |<br>| RssChannelHttpMessageConverter          | 读写RSS种子消息<br>1) T为Channel类型<br>2) 可读取application/rss+xml类型的数据<br>3) 响应信息的媒体类型为application/rss+xml |<br>| AtomFeedHttpMessageConverter            | 读写RSS种子消息<br>1) T为Feed类型<br>2) 可读取application/rss+xml类型的数据<br>3) 响应信息的媒体类型为application/rss+xml |</p>
<p>RequestMappingHandlerAdapter默认装配以下HttpMessageConverter:</p>
<ul>
<li>StringHttpMessageConverter</li>
<li>ByteArrayHttpMessageConverter</li>
<li>SourceHttpMessageConverter</li>
<li>AllEncompassingFormHttpMessageConverter</li>
</ul>
<p>需要装配其他类型的HttpMessageConverter, 可以在Web容器上下文中自定义一个RequestMappingHandlerAdapter</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个RequestMappingHandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> <span class="attr">p:messageConverters-ref</span>=<span class="string">"messageConverters"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HttpMessageConverter列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.BufferedImageHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.ByteArrayHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>HttpMessageConver&lt;T&gt;</code></p>
<p>将请求信息转换并绑定到处理方法的入参中的途径:</p>
<ul>
<li>使用@RequestBody/@ResponseBody对处理方法进行标注</li>
<li>使用<code>HttpEntity&lt;T&gt;</code>/<code>ResponseEntity&lt;T&gt;</code>作为处理方法的入参或返回值</li>
</ul>
<p>有以下结论：</p>
<ul>
<li>当控制器处理方法使用@RequestBody/@ResponseBody或<code>HttpEntity&lt;T&gt;</code>/<code>ResponseEntity&lt;T&gt;</code>时, Spring MVC才使用注册的HttpMessageConverter对请求/响应消息进行处理</li>
<li>当控制器处理方法使用@RequestBody/@ResponseBody或<code>HttpEntity&lt;T&gt;</code>/<code>ResponseEntity&lt;T&gt;</code>时, Spring首先根据请求头或响应头的Accept属性选择匹配的HttpMessageConverter, 然后根据参数类型或泛型类型的过滤得到匹配的HttpMessageConverter, 如果找不到可用的HttpMessageConverter则报错</li>
<li>@RequestBody/@ResponseBody不需要成对出现</li>
<li>@RequestBody/@ResponseBody和<code>HttpEntity&lt;T&gt;</code>/<code>ResponseEntity&lt;T&gt;</code>功能相似</li>
</ul>
</li>
<li><p>处理XML和JSON</p>
<ul>
<li>MarshallingHttpMessageConverter: 处理XML格式的请求或响应信息</li>
<li>Jaxb2RootElementHttpMessageConverter: 同上, 底层使用JAXB</li>
<li>MappingJackson2HttpMessageConverter: 处理JSON格式的请求或响应信息</li>
</ul>
<p>为RequestMappinghandlerAdapter装配可处理XML和JSON格式的请求/响应消息的HttpMessageConverter</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个RequestMappingHandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> <span class="attr">p:messageConverters-ref</span>=<span class="string">"messageConverters"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HttpMessageConverter列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.BufferedImageHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.ByteArrayHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.xml.MarshallingHttpMessageConverter"</span> <span class="attr">p:marshaller-ref</span>=<span class="string">"xmlMarshaller"</span> <span class="attr">p:unmarshaller-ref</span>=<span class="string">"xmlMarshaller"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明Marshaller, 使用XStream技术 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xmlMarshaller"</span> <span class="attr">class</span>=<span class="string">"org.springframework.oxm.xstream.XStreamMarshaller"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"streamDriver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用STAX对XML消息进行处理, STAX占用内存少, 响应速度很快 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.thoughtworks.xstream.io.xml.StaxDriver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"annotatedClasses"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用XStream的注解定义XML转换规则, 使用XStream注解的类在此声明 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>com.smart.domain.User<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过请求消息头的Content-Type及Accept属性确定响应消息的格式</p>
</li>
</ol>
<h4 id="使用-RestController"><a href="#使用-RestController" class="headerlink" title="使用@RestController"></a>使用@RestController</h4><p>为方便Rest的开发, Spring引入新的@RestController注解, 该注解已经标注了@ResponseBody和@Controller</p>
<p>使用REST风格开发应用程序时, 仅需以下两行配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.smart,*"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="处理模型数据"><a href="#处理模型数据" class="headerlink" title="处理模型数据"></a>处理模型数据</h4><p>Spring MVC提供类多种途径输出模型数据</p>
<ul>
<li>ModelAndView: 当处理方法返回类型为ModelAndView时, 方法体即可通过该对象添加模型数据</li>
<li>@ModelAttribute: 在方法入参标注该注解后, 入参的对象将会放到数据模型中</li>
<li>Map及Model: 方法入参为Model, ModelMap, Map当处理方法返回时, Map中的数据会自动添加到模型中</li>
<li>@SessionAttributes: 将模型中的某个属性暂存到HttpSession中, 以便多个请求之间可以共享这个属性</li>
</ul>
<ol>
<li><p>ModelAndView</p>
<p>即包含视图信息又包含模型数据信息. 可以简单的将模型数据看成一个Map&lt;String, Object&gt;对象</p>
</li>
<li><p>@ModelAttribute</p>
<p>在准备对视图进行渲染前, Spring MVC会进一步将模型中的数据转储到视图的上下文中并暴露给视图对象.</p>
</li>
<li><p>Map及Model</p>
<p>Spring MVC内部使用Model接口存储模型数据, 功能类似于Map</p>
<p>Spring MVC在调用方法前会创建一个隐含的模型对象, 作为模型数据的存储器. 如果处理方法入参为Map或Model类型, 会将隐含的模型的引用传递给这个入参.</p>
</li>
<li><p>@SessionAttributes</p>
<p>标注@SessionAttributes会将模型中对应的属性暂存到HttpSession中.</p>
</li>
</ol>
<p>Spring MVC对@ModelAttribute及@SessionAttributes处理遵循一个特定的流程, 当流程条件不满足时就会报错:</p>
<ol>
<li><p>Spring MVC在调用处理方法前， 在请求线程中自动创建一个隐含的模型数据</p>
</li>
<li><p>调用所有标注了@ModelAttribute的方法, 将方法返回值添加到隐含模型中</p>
</li>
<li><p>查看Session中的是否存在@SessionAttributes(“xxx”)所指定的xxx属性,  有则添加到隐含模型中, 隐含模型已存在xxx属性, 会覆盖模型中已有的属性值</p>
</li>
<li><p>对标注了@ModelAttribute(“xxx”)处理党风的入参按以下流程:</p>
<p>1) 如果隐含模型拥有名为xxx的属性, 将其赋给该如此, 再用请求消息填充该入参对象执行返回</p>
<p>2) 如果xxx时会话属性, 即处理类定义处标注了@SessionAttributes(“xxx”), 会尝试从会话中获取该属性, 并赋值给入参, 然后再用哪个请求消息填充该入参对象. 如果会话中找不到对应属性, 抛出HttpSessionRequiredException异常</p>
<p>3) 隐含模型中不存在xxx属性, 且xxx不是会话属性, 创建入参对象实例, 再用请求消息填充入参.</p>
</li>
</ol>
<h3 id="处理方法的数据绑定"><a href="#处理方法的数据绑定" class="headerlink" title="处理方法的数据绑定"></a>处理方法的数据绑定</h3><p>当请求消息到达真正需要调用的方法时(如指定的业务方法), Spring MVC还有很多工作要做, 包括数据转换, 数据格式化, 数据校验等</p>
<h4 id="数据绑定流程剖析"><a href="#数据绑定流程剖析" class="headerlink" title="数据绑定流程剖析"></a>数据绑定流程剖析</h4><p>Spring MVC通过反射机制对目标处理方法的签名进行分析, 将请求消息绑定到处理方法的入参中. 数据绑定的核心部件是DataBinder, 其运行机制描述如图:</p>
<p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/数据绑定.png" alt="数据绑定"></p>
<p>Spring MVC将ServletRequest对象及处理方法的入参对象实例传递给DataBinder, DataBinder首先调用装配在Spring Web上下文中的ConversionService组件进行数据类型转换, 数据格式化等工作, 将ServletRequest中的消息填充到入参对象中, 然后调用Validator组件对已经绑定了请求消息数据的入参对象进行数据合法性校验, 最终生成数据绑定结果BindingResult对象.</p>
<p>BindingResult包含了已完成数据绑定的入参对象, 包含相应的校验错误对象. </p>
<h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p>Java原生的PropertyEditor的不足:</p>
<ul>
<li>只能拥有字符串到Java对象的转换, 不适用于任意两个Java类型之间的转换</li>
<li>对源对象及目标对象所在的上下文信息不敏感, 在类型转换时不能利用这些上下文信息实施高级的转换逻辑</li>
</ul>
<ol>
<li><p>ConversionService</p>
<p>类型转换体系的核心接口. 定义了以下4个方法</p>
<ul>
<li><code>boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</code>: 判断是否可以将Java类转换为另一个Java类</li>
<li>Bolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType): 需转换的类将以成员变量的方式出现在宿主类中. TypeDescriptor不但描述了需要转换的类的信息, 还描述了从宿主类的上下文信息, 如成员变量上的注解, 成员变量是否以数组, 集合或Map的方式呈现等. </li>
<li><code>&lt;T&gt; T conver(Object source, Class&lt;T&gt; targetType)</code>: 将原类型对象转换为目标类型对象</li>
<li>Object conver(Object source, TypeDescriptor sourceType, TypeDescriptor targetType): 将对象从原类型对象转换为目标类型对象, 此时往往会用到所在宿主类的上下文信息</li>
</ul>
<p>可以利用ConversionServiceFactoryBean在Spring的上下文中定义一个ConversionService. Spring自动识别ConversionService, 并在Bean属性配置及Spring MVC处理方法入参绑定等场合使用它进行数据转换.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过ConversionServiceFactoryBean的converters属性注册自定义的类型转换器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.MyCustomConverter1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.MyCustomConverter2"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring支持哪些转换器</p>
<p>Spring定义了3中类型的转换器接口, 实现任意一个转换器接口都可以作为自定义转换器注册到ConversionServiceFactoryBean中</p>
<ul>
<li>Converter&lt;S, T&gt;</li>
<li>GenericConverter</li>
<li>ConverterFactory</li>
</ul>
<p>Converter接口只定义了一个接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负责将S类型的对象转换为T类型的对象.</p>
<p>ConverterFactory接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  &lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>S为转换的源类型, R为目标类型的基类.</p>
<p>Converter只负责将一个类型的对象转换为另一个类型的对象, 没有考虑类型的对象所在宿主类上下文的信息.</p>
<p>GEnericConverter接口会根据源类对象及目标类对象所在宿主类的上下文信息进行类型转换工作, 接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePar&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConvertiblePar封装了源类型和目标类型, 组成一个”对子”, TypeDescriptor包含了需转换类型对象所在宿主类的信息, GenericConverter可以利用上下文信息进行类型转换</p>
<p>conditionalGenericConverter扩展于GenericConverter接口, 并添加一个接口方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor source, TypeDescriptor targetType)</span></span>;</span><br></pre></td></tr></table></figure>
<p>根据源类型及目标类型所在宿主类的上下文信息决定是否要进行类型转换, 只有该接口方法返回true时, 才调用convert()方法完成类型转换.</p>
<p>Spring在Bean属性配置及Spring MVC请求消息绑定时将利用这个ConversionService实例完成类型转换工作.</p>
<p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/ConversionService创建过程示意图.png" alt="ConversionService创建过程示意图"></p>
</li>
<li><p>使用@IntBinder和WebBindingInitializer装配自定义编辑器</p>
<p>可以在控制器中使用@InitBinder添加自定义的编辑器, 也可以通过WebBindingInitializer装配全局范围内使用的编辑器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapper</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在控制器初始化前调用</span></span><br><span class="line">  <span class="meta">@InitBinder</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册一个自定义的编辑器</span></span><br><span class="line">    binder.registerCustomEditor(User.class, <span class="keyword">new</span> UserEditor());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用addCustomFormatter指定格式化程序实现, 这样久不需要实现一个PropertyEditor的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">  binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望在全局范围内使用UserEditor编辑器, 可实现WebBindingInitializer接口并在实现类中注册UserEditor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBindingInitializer</span> <span class="keyword">implements</span> <span class="title">WebBindingInitializer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder, WebRequest request)</span> </span>&#123;</span><br><span class="line">    binder.registerCustomEditor(User.class, <span class="keyword">new</span> UserEidtor());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring上下文中通过RequestMappingHandlerAdapter装配MyBindingInitializer</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webBindingInitializer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.web.MyBindingInitializr"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring MVC按以下优先顺序查找对应的类型编辑器</p>
<ul>
<li>查询通过@InitBinder装配的自定义编辑器</li>
<li>查询通过ConversionService装配的自定义转换器</li>
<li>查询通过WebBindingInitializer装配的自定义编辑器</li>
</ul>
</li>
</ol>
<h4 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h4><p>Spring格式化框架负责从格式化的数据中获取真正的数据以完成数据绑定, 并将处理完成的数据输出为格式化的数据</p>
<ol>
<li><p><code>Formatter&lt;T&gt;</code></p>
<p><code>Formatter&lt;T&gt;</code>接口扩展于<code>Printer&lt;T&gt;</code>和<code>Parser&lt;T&gt;</code>几口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formatter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Printer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Parser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Printer&lt;T&gt;</code>负责对象的格式化输出, <code>Parser&lt;T&gt;</code>负责兑现的格式化输入, 接口中各定义了一个方法</p>
<p><code>Printer&lt;T&gt;</code>接口将类型为T的成员对象根据本地化的不同输出为不同的格式化字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">print</span><span class="params">(T fieldValue, Locale locale)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>Parser&lt;T&gt;</code>接口根据本地化信息将一个格式化的字符串转换为T类型的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">parse</span><span class="params">(String clientValue, Locale locale)</span> <span class="keyword">throws</span> ParseException</span>;</span><br></pre></td></tr></table></figure>
<p>Spring提供类注解驱动的属性对象格式化功能, 可在Bean属性设置, Spring MVC处理方法入参数据绑定, 模型数据输出时自动通过注解应用格式化功能</p>
</li>
<li><p>注解驱动格式化的重要接口</p>
<p>Spring还提供了<code>AnnotationFormatterFactory&lt;A extends Annotation&gt;</code>接口</p>
<ul>
<li>Set&lt;Class&lt;?&gt;&gt; get FieldTypes(): 注解A的应用范围, 即哪些属性类可以标注A注解</li>
<li><code>Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType)</code>: 根据注解A获取特定属性类型的Parser</li>
<li><code>Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType): 根据注解A获取特定属性类型的Printer</code></li>
</ul>
<p>Spring提供了两个内建的实现类</p>
<ul>
<li>NumberFormatAnnotationFormatterFactory: 支持对数字类型的属性使用@NumberFormat注解</li>
<li>JobDateTimeFormatAnnotationFormatterFactory: 支持对日期类型的属性使用@DateTimeFormat注解</li>
</ul>
</li>
<li><p>启用注解驱动格式化功能</p>
<p>对属性对象的输入/输出进行格式化, 从本质上讲依然属于”类型转换”</p>
<p>FormattingConversionService扩展了GenericConversionService, 因此它既具有类型转换功能, 又具有格式化功能</p>
<p>FormattingConversionServiceFactoryBean工厂类用于构建FormattingConversionService, 即可以注册自定义的转换器, 还可以注册自定义的注解驱动逻辑</p>
<p>FormattingConversionServiceFactoryBean内部会自动注册NumberFormatAnnotationFormatterFactory和JodaDateTimeFormatAnnotationFormatterFactory</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"comversionService"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 替换原来的ConversionServiceFactoryBean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.domain.StringToUserConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h4><ol>
<li><p>JSR-303</p>
<p>Java为Bean数据合法性校验所提供的标准框架, 包括在Java EE6.0中. 通过在Bean属性上标注类似于@NotNull, @Max等标准的注解指定校验规则, 并通过标准的验证接口对Bean进行验证</p>
<p>|            注解            |                         功能说明                         |<br>| :————————: | :——————————————————: |<br>|           @Null            |                  被注释的元素必须为null                  |<br>|          @NotNull          |                 被注释的元素必须不为null                 |<br>|        @AssertTrue         |                  被注释的元素必须为true                  |<br>|        @AssertFalse        |                 被注释的元素必须为false                  |<br>|        @Min(value)         | 被注释的元素必须必须是一个数字, 必须大于等于指定的最小值 |<br>|        @Max(value)         | 被注释的元素必须必须是一个数字, 必须小于等于指定的最大值 |<br>|     @DecimalMin(value)     |   被注释的元素必须是一个数字, 必须大于等于指定的最小值   |<br>|     @DecimalMax(value)     |   被注释的元素必须是一个数字, 必须小于等于指定的最大值   |<br>|      @Size(max, min)       |         被注释的元素必须的大小必须在指定的范围内         |<br>| @Digits(integer, fraction) |   被注释的元素必须必须是一个数字, 必须在可接受的范围内   |<br>|           @Past            |           被注释的元素必须必须是一个过去的日期           |<br>|          @Future           |           被注释的元素必须必须是一个将来的日期           |<br>|           @Email           |            被注释的元素必须必须是电子邮箱地址            |<br>|          @Length           |           被注释的字符串的大小必须在指定范围内           |<br>|         @NotEmpty          |                  被注释的字符串必须非空                  |<br>|           @Rang            |            被注释的元素必须必须在合适的范围内            |</p>
</li>
<li><p>Spring校验框架</p>
<p>Spring的DataBinder在进行数据绑定时, 可以同时调用校验框架完成数据校验工作, 在Spring MVC可直接通过注解驱动的方式进行数据校验 </p>
<p>Validator接口拥有以下两个方法:</p>
<ul>
<li>boolean supports(Class&lt;?&gt; clazz): 该校验器能够对clazz类型的对象进行校验</li>
<li>void validate(Object target, Errors errors): 对目标类target进行校验, 并将校验错误记录在errors中</li>
</ul>
<p>LocalValidatorFactoryBean即实现了Spring的Validator接口, 又实现了JSR-303的Validator接口</p>
<p>只要在Spring容器中定义一个LocalValidatorFactoryBean, 即可将其注入需要数据校验的Bean中.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring MVC数据校验</p>
<p><code>&lt;mvc:annotation-driven&gt;</code>默认装配一个LocalValidatorFactoryBean, 通过在处理方法入参上标注@Valid注解, 即可让Spring MVC在完成数据绑定后执行数据校验工作</p>
<p>使用注解所声明的限制规则进行数据校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(path=<span class="string">"/handle"</span>)</span><br><span class="line">  <span class="comment">// 在入参对象前添加@Valid注解, 同时在其后声明一个BindingResult入参</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@Valid User user, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据BindingResult即可判断是否存在错误</span></span><br><span class="line">    <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC通过对处理方法签名的规约保存校验结果: 前一个表单/命令对象的校验结果保存在其后的入参中, 这个保存校验结果的入参必须为BindingResult或Errors类型.</p>
<p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/数据校验时处理方法入参的签名规约.png" alt="数据校验时处理方法入参的签名规约"></p>
</li>
<li><p>如何获取校验结果</p>
<p>处理方法内部可以通过BindingResult或Errors入参对 i 选哪个获取错误信息</p>
<p>以下是几个常用的方法</p>
<ul>
<li>FieldError getFieldError(String filed): 根据属性名获取对应的校验错误</li>
<li><code>List&lt;FieldError&gt; getFieldErrors()</code>: 获取所有的属性校验错误</li>
<li>Object getFieldValue(String field): 获取属性值</li>
<li>int getErrorCount(): 获取错误数量</li>
</ul>
</li>
<li><p>如何在页面中显示错误</p>
<p>校验结果对象和被校验的表单/命令对象是一对一的关系, 但”隐含模型”处理存储模型数据外, 还保存了所有被校验的表单/命令对象的校验结果. </p>
<p>隐含模型中的所有数据最终将通过HttpServletRequest的属性列表暴露给JSP视图对象</p>
</li>
<li><p>自定义校验规则</p>
<p>给请求处理类装配一个自定义的Validator, 或直接在处理方法中使用自定义的Validator对入参进行校验</p>
<p>使用@InitBinder注解的initBinder()方法装配自定义MyValidator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在进行数据绑定时使用的校验器</span></span><br><span class="line">  binderSetValidator(<span class="keyword">new</span> MyValidator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助请求处理方法的签名传递以恶搞Errors或BindingResult对象, 然后在处理方法直接校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(path=<span class="string">"handle"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@ModelAttribute(<span class="string">"user"</span>)</span> User user, BindingResult bindingResult) </span>&#123; <span class="comment">// 声明一个BindingResult入参</span></span><br><span class="line">    <span class="comment">// 使用校验器工具类进行校验</span></span><br><span class="line">    ValidationUtils.rejectIfEmptyOrWhitespace(bindingResult, <span class="string">"userName"</span>, <span class="string">"required"</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (<span class="string">"aaaa"</span>.equalsIgnoreCase(uesr.getUserName())) &#123;</span><br><span class="line">     <span class="comment">// 手工生成一条错误信息</span></span><br><span class="line">     bindingResult.rejectValue(<span class="string">"userName"</span>, <span class="string">"reserved"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h3><p>请求处理方法执行完成后, 最终返回一个ModelAndView对象.</p>
<p>返回String, View, ModelMap等类型的处理方法, Spring MVC也会在内部将它装配成一个ModelAndView对象</p>
<p>Spring MVC借助视图解析器(ViewResolver)得到最终的视图对象</p>
<p>处理器的工作重点聚焦在生产模型数据的工作上, 从二实现MVC的充分解耦</p>
<h4 id="认识视图"><a href="#认识视图" class="headerlink" title="认识视图"></a>认识视图</h4><p>视图的作用是渲染模型数据, 将数据以某种形式呈现给用户.</p>
<p>Spring定义了一个高度抽象的View接口, 该接口定义了两个方法:</p>
<ul>
<li>String getContentType():  视图对应的MIME类型, 如: text/html, image/jpeg</li>
<li>void render(Map model, HttpServletRequest request, HttpServletResponse response): 将模型数据以某种MIME类型渲染出来</li>
</ul>
<p>通常视图对象由视图解析器负责实例化</p>
<p>不同的视图实现技术对应不同的View实现类</p>
<table>
<thead>
<tr>
<th style="text-align:center">视图类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">InternalResourceView</td>
<td style="text-align:center">将JSP或其他资源封装成一个视图, InternalResourceViewResolver默认使用的视图实现类</td>
</tr>
<tr>
<td style="text-align:center">JstlView</td>
<td style="text-align:center">如果JSP文件中使用了JSTL国际化标签的功能, 则需要使用该视图类</td>
</tr>
<tr>
<td style="text-align:center">XsltView</td>
<td style="text-align:center">XSTL驱动的视图</td>
</tr>
<tr>
<td style="text-align:center">TilesView</td>
<td style="text-align:center">基于Tiles页面布局的视图</td>
</tr>
<tr>
<td style="text-align:center">TileJstlView</td>
<td style="text-align:center">如果Tiles模板的JSP组成文件使用了JSTL, 需要使用该视图替换TilesView视图</td>
</tr>
<tr>
<td style="text-align:center">AbstractExcelView</td>
<td style="text-align:center">Execel文档视图抽象类, 开发者通过该抽象类实现自己的Excel文档视图, 基于POI构造Excel文档</td>
</tr>
<tr>
<td style="text-align:center">AbstractJExcelView</td>
<td style="text-align:center">和AbstractExcelView类似, 它基于JExcelAPI</td>
</tr>
<tr>
<td style="text-align:center">AbstractPdfStamperView</td>
<td style="text-align:center">PDF文档视图的抽象类, 通过AcroForm技术对PDF文档进行操作</td>
</tr>
<tr>
<td style="text-align:center">AbstractPdfView</td>
<td style="text-align:center">PDF文档视图抽象类, 通过该抽象类实现自己的PDF文档视图, 基于iText构造PDF文档</td>
</tr>
<tr>
<td style="text-align:center">FreeMarkerView</td>
<td style="text-align:center">使用FreeMarker模板引擎的视图</td>
</tr>
<tr>
<td style="text-align:center">VelocityLayoutView<br>VelocityToolbaxView<br>VelocityView</td>
<td style="text-align:center">几个使用Velocity模板引擎的视图</td>
</tr>
<tr>
<td style="text-align:center">ConfigurableJasperReportView<br>JasperReportsCsvView<br>JasperResportsHtmlView<br>JasperReportsMultiFormatView<br>JasperResportsPdfView<br>JasperReportsXlsView</td>
<td style="text-align:center">几个使用JasperReports报表技术的视图</td>
</tr>
<tr>
<td style="text-align:center">MarshallingView</td>
<td style="text-align:center">通过oxm的Marshaller技术将模型数据以XML方式输出</td>
</tr>
<tr>
<td style="text-align:center">MappingJaskson2JsonView</td>
<td style="text-align:center">将模型数据通过Jaskson开源框架的ObjectMapper以JSON方式输出</td>
</tr>
<tr>
<td style="text-align:center">RedirectView</td>
<td style="text-align:center">进行重定向的视图, 可以重定向到上下文的绝对路径或相对路径下, 也可以重定向到当前请求的相对路径</td>
</tr>
</tbody>
</table>
<h4 id="认识视图解析器"><a href="#认识视图解析器" class="headerlink" title="认识视图解析器"></a>认识视图解析器</h4><p>Spring MVC为逻辑视图名的解析提供了不同的策略, 可以在Web上下文中配置一种或多种解析策略, 并指定它们的先后顺序.</p>
<p>视图解析工作即将逻辑视图名解析为一个具体的视图对象.</p>
<p>所有视图解析器都实现了ViewResolver接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span></span>;</span><br></pre></td></tr></table></figure>
<p>resolveViewName(): 根据逻辑视图名和本地化对象的到一个视图对象</p>
<table>
<thead>
<tr>
<th style="text-align:center">视图解析器类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BeanNameViewResolver</td>
<td style="text-align:center">将逻辑视图名解析为一个Bean, Bean的id等于逻辑视图名</td>
</tr>
<tr>
<td style="text-align:center">XmlViewResolver</td>
<td style="text-align:center">和BeanNameViewResolver类似, 只不过模板视图Bean对象定义在一个独立的XML文件, 而非定义在DispatcherServlet上下文的主配置文件中</td>
</tr>
<tr>
<td style="text-align:center">ResourceBundleViewResolver</td>
<td style="text-align:center">在国际化资源文件中定义视图实现及相关的信息, 使用该视图解析器可以为不同的本地化类型提供不同的解析结果</td>
</tr>
<tr>
<td style="text-align:center">InternalResourceViewResolver</td>
<td style="text-align:center">将视图解析为一个URL文件, 映射为保存在WEB-INF模板的呈现文件(如JSP)</td>
</tr>
<tr>
<td style="text-align:center">XsltViewResolver</td>
<td style="text-align:center">将视图名解析为一个指定XSLT样式表的URL文件</td>
</tr>
<tr>
<td style="text-align:center">JasperReportsViewResolver</td>
<td style="text-align:center">JsperReports是基于Java的开源报表工具, 该解析器将视图名解析为报表文件所对应的URL</td>
</tr>
<tr>
<td style="text-align:center">FreeMarkerViewResolver</td>
<td style="text-align:center">解析基于FreeMarker模板技术的模板文件</td>
</tr>
<tr>
<td style="text-align:center">VelocityViewResolver<br>VelocityLayoutViewResolver</td>
<td style="text-align:center">解析基于Velocity模板技术的模板文件</td>
</tr>
<tr>
<td style="text-align:center">ContentNegotiatingViewResolver</td>
<td style="text-align:center">不负责具体的视图解析, 而是作为一个中间人的角色根据请求所要求的MIME类型， 从上下文选择一个合适的视图解析器, 在将视图解析工作委托其负责</td>
</tr>
</tbody>
</table>
<h4 id="JSP和JSTL"><a href="#JSP和JSTL" class="headerlink" title="JSP和JSTL"></a>JSP和JSTL</h4><ol>
<li><p>使用InternalResourceViewResolver</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">p:prefix</span>=<span class="string">"/WEB-INF/views"</span> <span class="attr">p:suffix</span>=<span class="string">".jsp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/逻辑视图名解析为URI资源.png" alt="逻辑视图名解析为URI资源"></p>
<p>InternalResourceViewResolver默认使用InternalResourceView作为视图实现类, 如果需要使用JSTL国际化功能, 需要使用JstlView替换默认的视图实现类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> <span class="attr">p:prefix</span>=<span class="string">"/WEB-INF/views"</span> <span class="attr">p:suffix</span>=<span class="string">".jsp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="模板视图"><a href="#模板视图" class="headerlink" title="模板视图"></a>模板视图</h4><p>在Spring Web上下文中配置FreeMarker</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过FreeMarkerConfigurer配置FreeMarker环境, templateLoaderPath指定模板文件存放路径, defaultEncoding指定编码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span> <span class="attr">p:templateLoaderPath</span>=<span class="string">"/WEB-INF/ftl"</span> <span class="attr">p:</span> <span class="attr">defaultEncoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 对FreeMarker的自定义属性进行统一的设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"freemarkerSettings"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"classic_compatible"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"</span> <span class="attr">p:order</span>=<span class="string">"5"</span> <span class="attr">p:suffix</span>=<span class="string">".ftl"</span> <span class="attr">p:contentType</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h4><p>通过扩展AbstractExcelView定义显示用户列表的Excel视图类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserListExcelView</span> <span class="title">exnteds</span> <span class="title">AbstractExcelView</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildExcelDocument</span><span class="params">(Map&lt;String, Object&gt; model, HSSFWorkbook workbook, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Excel文档名称必须编码为iso8859-1, 否则会显示乱码</span></span><br><span class="line">    response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"inline; filename="</span> + <span class="keyword">new</span> String(<span class="string">"用户列表"</span>.getBytes(), <span class="string">"iso8859-1"</span>));</span><br><span class="line">    List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">"userList"</span>);</span><br><span class="line">    HSSFSheet sheet = workbook.createSheet(<span class="string">"users"</span>);</span><br><span class="line">    HSSFRow header = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">    header.createCell(<span class="number">0</span>).setCellValue(<span class="string">"账号"</span>);</span><br><span class="line">    header.createCell(<span class="number">1</span>).setCellValue(<span class="string">"姓名"</span>);</span><br><span class="line">    header.createCell(<span class="number">2</span>).setCellValue(<span class="string">"生日"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rowNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">      HSSRow row = sheet.createRow(rowNum++);</span><br><span class="line">      row.createCell(<span class="number">0</span>).setCellValue(user.getUserName());</span><br><span class="line">      row.createCell(<span class="number">1</span>).setCellValue(user.getRealName());</span><br><span class="line">      String createDate = DateFormUtils.form(user.getBirthday(), <span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">      row.createCell(<span class="number">2</span>).setCellValue(createDate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写好的Excel视图类, 必须在Spring MVC配置文件进行相关配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span> <span class="attr">p:order</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userListExcel"</span> <span class="attr">class</span>=<span class="string">"com.smart.web.UserListExcelView"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h4><p>PDF视图和Excel类似, 也使用一个Bean作为视图对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserListPdfView</span> <span class="keyword">extends</span> <span class="title">AbstractPdfView</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildPdfDocument</span><span class="params">(Map&lt;String, Object&gt; model, Document document, PdfWriter writer, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"inline; filename="</span> + <span class="keyword">new</span> String(<span class="string">"用户列表"</span>.getBytes(), <span class="string">"iso8859-1"</span>));</span><br><span class="line">    List&lt;User&gt; userList = (List&lt;User&gt;) model.get(<span class="string">"userList"</span>);</span><br><span class="line">    Table table = <span class="keyword">new</span> Table(<span class="number">3</span>);</span><br><span class="line">    table.setWidth(<span class="number">80</span>);</span><br><span class="line">    table.setBorder(<span class="number">1</span>);</span><br><span class="line">    table.getDefaultCell.setHorizontalAlignment(Element.ALIGN_CENTER);</span><br><span class="line">    table.getDefaultCell().setVerticalAlignment(Element.ALIGN_MIDDLE);</span><br><span class="line">    <span class="comment">// 使用中文字体</span></span><br><span class="line">    BaseFont cnBaseFont = BaseFont.createFont(<span class="string">"STSongStd-Light"</span>, <span class="string">"UniGB-UCS2-H"</span>, <span class="keyword">false</span>);</span><br><span class="line">    Font cnFont = <span class="keyword">new</span> Font(CnBaseFont, <span class="number">10</span>, Font.NORMAL, Color.BLUE);</span><br><span class="line">    <span class="comment">// 对中文字符, 要使用中文字段构造Cell对象, 否则会产生乱码</span></span><br><span class="line">    table.addCell(buildFontCell(<span class="string">"账号"</span>, cnFont));</span><br><span class="line">    table.addCell(buildFontCell(<span class="string">"姓名"</span>, cnFont));</span><br><span class="line">    table.addCell(buildFontCell(<span class="string">"生日"</span>, cnFont));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">      table.addCell(user.getUserName());</span><br><span class="line">      table.addCell(buildFontCell(user.getRealName(), cnFont));</span><br><span class="line">      String createDate = DataFormatUtils.format(user.getBirthday(), <span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">      table.addCell(createDate);</span><br><span class="line">    &#125;</span><br><span class="line">    document.add(table);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将需要输出的内容通过Phrase对象使用特殊字体进行封装</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Cell <span class="title">buildFontCell</span><span class="params">(String content, Font font)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Phrase phrase = <span class="keyword">new</span> Phrase(content, font);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Cell(phrase);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserListPdfView可以采用BeanNameViewResolver作为视图解析器, 需要在Spring MVC配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userListPdf"</span> <span class="attr">class</span>=<span class="string">"com.smart.web.UserListPdfView"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="输出XML"><a href="#输出XML" class="headerlink" title="输出XML"></a>输出XML</h4><p>在Spring MVC配置文件中添加MarshallingView的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userListXml"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.xml.MarshallingView"</span> <span class="attr">p:modelKey</span>=<span class="string">"userList"</span> <span class="attr">p:marshaller-ref</span>=<span class="string">"xmlMarshaller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xmlMarshaller"</span> <span class="attr">class</span>=<span class="string">"org.springframework.oxm.xstrem.XStreamMarshaller"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"streamDriver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.thoughtworks.xstream.io.xml.StaxDriver"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"annotatedClasses"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.smart.domain.User<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MarshallingView默认会将模型中的所有属性都转换为XML. 允许通过modelKey指定模型中的哪个属性需要输出为XML</p>
<h4 id="输出JSON"><a href="#输出JSON" class="headerlink" title="输出JSON"></a>输出JSON</h4><p>MappingJackson2JsonView借助Jackson框架的ObjectMapper将模型数据转换为JSON格式输出.</p>
<p>可以通过BeanNameViewResolver进行解析, 因此仅需要在Spring MVC配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userListJson"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.json.MappingJackson2JsonView"</span> <span class="attr">p:modelKeys</span>=<span class="string">"userList"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下MappingJackson2JsonView会将模型中的所有数据全部输出为JSON, 可以通过modelKeys指定模型中的哪些属性需要输出</p>
<h4 id="混合使用多种视图技术"><a href="#混合使用多种视图技术" class="headerlink" title="混合使用多种视图技术"></a>混合使用多种视图技术</h4><ol>
<li><p>ContentNegotiatingViewResolver</p>
<p>REST风格的应用对资源的URL定义有严格的要求: 一个资源对象对应唯一的URL.</p>
<p>HttpMessageConverter对标注了@ResponseBody或返回值为ResponseEntity的处理器方法进行响应信息转换的内容, Spring MVC可以根据请求报文中的Accept属性选择合适的HttpMessageConverter将处理方法的返回值以XML, JSON等不同的形式输出响应. 调用者可以通过设置请求报文头的Accept值控制服务器端返回的数据格式, 从而实现对同一资源采用相同URL的REST编程风格</p>
<p>基于HtttMessageConverter的实现方式存在以下限制：</p>
<ul>
<li>只能通过请求报文头的Accept值控制服务器端返回的数据格式, 一般情况下, 该值由浏览器自己决定</li>
<li>无法通过URL扩展名或请求参数控制服务器端的资源输出格式, 因此无法将其对应一个URL发布出去</li>
<li>如果希望以XML, JSON, 一个网页等形式输出资源, 则HttpMessageConverter很难达到要求. HttpMessageconverter很难调用一个视图对象渲染模型, 它直接负责将资源输出为某一内容形式</li>
</ul>
<p>ContentNegotiatingViewResolver根据请求内容从上下文中选择合适的视图解析器负责解析. </p>
<p>ContentNegotiatingViewResolver根据请求所要求的MIME类型决定由哪个视图解析器负责处理, 它按以下方式工作:</p>
<p>1) 如果其favorPathExtension属性设置为true(默认为true), 则根据URL重点饿文件扩展名确定MIME类型</p>
<p>2) 如果其favorParameter属性设置为true(默认为false), 则根据请求参数的值确定MIME类型, 默认的请求参数是formart. 可以通过parameterName属性指定一个自定义参数</p>
<p>3) 如果没有找到对应的MIME类型, 且Java Activation Framework(JAF)位于类路径下, 则通过JAF的FileTypeMap.getContentType(url)方法对URL进行判断, 以获得对应的MIME类型</p>
<p>4) 如果以上步骤都失败, 且ignoreAcceptHeader属性设置为false(默认为false), 则采用Accept请求报文头的值确定MIME. 不同的浏览器产生的Accept头都是不一样的, 一般不建议采用Accept确定MIME类型</p>
</li>
<li><p>使用同一URL获取不同形式的返回内容</p>
<p>在Spring MVC配置文件中添加以下配置片段, 配置一个ContentNegotiatingViewResolver, 采用请求参数指定内容资源的返回类型</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不支持扩展文件名, 不支持Accept报文头指定MIME类型, 通过请求参数指定MIME类型, 参数名为content, 请求类型的参数值和MIME类型的映射列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"contentNegotiationManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.accept.ContentNegtiationManagerFactoryBean"</span> <span class="attr">p:ignoreAcceptHeader</span>=<span class="string">"true"</span> <span class="attr">p:favorPathExtendsion</span>=<span class="string">"false"</span> <span class="attr">p:favorParameter</span>=<span class="string">"true"</span> <span class="attr">p:parameterName</span>=<span class="string">"content"</span> <span class="attr">p:defaultContentText</span>=<span class="string">"text/html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">    html=text/html</span><br><span class="line"> xml=application/xml</span><br><span class="line">    json=application/json</span><br><span class="line">  <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使该视图解析器优先级最高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.ContentNegotiatingViewResolver"</span> <span class="attr">p:order</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contentNegotiationManager"</span> <span class="attr">ref</span>=<span class="string">"contentNegotiationManager"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultViews"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- JSON视图对象 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.json.MappingJackson2JsonView"</span> <span class="attr">p:modelKeys</span>=<span class="string">"userList"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- XML视图对象 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.xml.MarshallingView"</span> <span class="attr">p:modelKey</span>=<span class="string">"userList"</span> <span class="attr">p:marshaller-ref</span>=<span class="string">"xmlMarshaller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下是上下文中已经配置的视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span> <span class="attr">p:order</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">p:order</span>=<span class="string">"100"</span> <span class="attr">p:viewClass</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> <span class="attr">p:prefix</span>=<span class="string">"/WEB-INF/views/"</span> <span class="attr">p:suffix</span>=<span class="string">".jsp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>###本地化解析</p>
<h4 id="本地化的概念"><a href="#本地化的概念" class="headerlink" title="本地化的概念"></a>本地化的概念</h4><p>Web应用根据客户端的设置判断客户端的本地化类型, 浏览器中设置的本地化类型会包含在HTML请求报文头中的Accept-Language参数发送给Web服务器.</p>
<p>默认情况下, Spring MVC根据Accept-Language参数判断客户端的本地化类型, 它还提供了多种指定客户端本地化类型的方式, 如通过Cookie, Session指定.</p>
<p>事实上, 当收到请求是, Spring MVC在上下文中寻找一个本地化解析器(LocaleResolver), 找到后使用它获取请求所对应的本地化类型信息</p>
<p>Spring还允许装配一个动态更改本地化类型的拦截器, 这样通过指定一个请求参数就可以控制单个请求的本地化类型.</p>
<p>Spring提供以下4个本地化解析器:</p>
<ul>
<li>AcceptHeaderLocaleResolver: 根据HTTP报文头的Accept-Language参数确定本地化类型. 如果没有显示定义本地化解析器, 则Spring MVC默认采用AcceptHeaderLocaleResolver</li>
<li>CookieLocaleResolver: 根据指定的Cookie值确定本地化类型</li>
<li>SessionLocaleResolver: 根据Session中特定的属性值确定本地化类型</li>
<li>LocaleChangeInterceptor: 从请求参数中获取本次请求对应的本地化类型</li>
</ul>
<h4 id="使用CookieLocaleResolver"><a href="#使用CookieLocaleResolver" class="headerlink" title="使用CookieLocaleResolver"></a>使用CookieLocaleResolver</h4><p>只需在Spring MVC上下文配置一个CookieLocaleResolver就可以, DispatcherServlet会自动识别本地化解析器并装配它</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span> <span class="attr">p:cookieName</span>=<span class="string">"clientLanguage"</span> <span class="attr">p:cookieMaxAge</span>=<span class="string">"10000"</span> <span class="attr">p:cookiePath</span>=<span class="string">"/"</span> <span class="attr">p:defaultLocale</span>=<span class="string">"zh_CN"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cookieName: 客户端保存本地化类型的Cookie名</li>
<li>cookieMaxAge: Cokkie最大存活秒数</li>
<li>cookiePath: Cookie保存路径</li>
<li>defaultLocale: 默认本地化类型</li>
</ul>
<h4 id="使用SessionLocaleResolver"><a href="#使用SessionLocaleResolver" class="headerlink" title="使用SessionLocaleResolver"></a>使用SessionLocaleResolver</h4><p>SessionLocaleResolver查找Session中属性名为SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME属性, 并将其转换为Locale对象, 以此作为客户端的本地化类型.</p>
<p>在Spring MVC上下文的配置文件中添加以下配置即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.SessionLocaleResolver"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用LocaleChangeInterceptor"><a href="#使用LocaleChangeInterceptor" class="headerlink" title="使用LocaleChangeInterceptor"></a>使用LocaleChangeInterceptor</h4><p>用户可以通过对URL的控制返回不同本地化的页面</p>
<p>在Spring MVC上下文中通过<code>&lt;mvc:interceptors&gt;</code>配置过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span> <span class="attr">p:cookieName</span>=<span class="string">"clientLanguage"</span> <span class="attr">p:cookieMaxAge</span>=<span class="string">"10000"</span> <span class="attr">p:cookiePath</span>=<span class="string">"/"</span> <span class="attr">p:defaultLocale</span>=<span class="string">"zh_CN"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>LocaleChangeInterceptor主要任务是从请求中获取本地化类型并将其设置给真正的本地化解析器, 所以在配置LocaleChangeInterceptor之前, 必须在上下文中先配置一个本地化解析器. 只能选择CookieLocaleResolver或SessionLocaleResolver</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>Spring MVC为文件上传提供了直接支持, 通过即插即用的MultipartResolver实现的. Spring使用Jakarta Commons FileUpload技术实现了一个MultipartResolver实现类: CommonsMultipartResolver.</p>
<h4 id="配置MultipartResolver"><a href="#配置MultipartResolver" class="headerlink" title="配置MultipartResolver"></a>配置MultipartResolver</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="attr">p:defaultEncoding</span>=<span class="string">"UTF-8"</span> <span class="attr">p:maxUploadSize</span>=<span class="string">"5242880"</span> <span class="attr">p:uploadTempDir</span>=<span class="string">"file:/d:/temp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>defaultEncoding: 请求的编码格式, 默认为ISO-8859-1, 必须和用户JSP的pageEncoding属性一致</li>
<li>maxUploadSize: 上传文件大小上限, 单位为字节</li>
<li>uploadTempDir: 文件上传过程中所使用的临时目录, 文件上传完成后, 临时目录中的临时文件会被自动清除</li>
</ul>
<h4 id="编写控制器和文件上传表单页面"><a href="#编写控制器和文件上传表单页面" class="headerlink" title="编写控制器和文件上传表单页面"></a>编写控制器和文件上传表单页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(path=<span class="string">"/upload"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">updateThumb</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">      file.transferTo(<span class="keyword">new</span> File(<span class="string">"d:/temp/"</span> + file.getOriginalFilename()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"redirect:fail.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC会将上传文件绑定到MultipartFile对象中, MultipartFile提供了获取上传文件内容, 文件名等方法, 通过transferTo()方法可以将文件存储在硬件中</p>
<ul>
<li>byte[] getBytes(): 获取文件数据</li>
<li>String getContentType(): 获取文件MIME类型, 如image/jpeg, text/plain等</li>
<li>InputStream getInputStream(): 获取文件流</li>
<li>String getName(): 获取表单中文件组件的名字</li>
<li>String getOriginalFilename(): 获取上传文件原名</li>
<li>long getSize(): 获取文件字节大小, 单位为Byte</li>
<li>boolean isEmpty(): 是否有上传的文件</li>
<li>void transferTo(File dest): 将上传文件保存到一个目录文件中</li>
</ul>
<p>负责上传文件的表达编码类型必须为<code>multipart/form-data</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="WebSocket支持"><a href="#WebSocket支持" class="headerlink" title="WebSocket支持"></a>WebSocket支持</h3><h4 id="使用WebSocket"><a href="#使用WebSocket" class="headerlink" title="使用WebSocket"></a>使用WebSocket</h4><p>Spring主要为WebSocket通信提供以下几个方面的支持</p>
<ul>
<li>发送和接收消息的API</li>
<li>用来发送消息的模板</li>
<li>支持SockJS, 用来解决浏览器, 服务器及代理不支持WebSocket的问题</li>
</ul>
<p>WebSocket通信可以用在任何类型的应用中, 最简单的形式是在两个应用质检建立通信通道<img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/应用之间的WebSocket通信.png" alt="应用之间的WebSocket通信"></p>
<p>在浏览器中使用JavaScript开启一个到达服务器的连接, 服务器通过这个连接发送更新到浏览器中, 相对于传统的在Web端轮询服务器及使用Flash中的Socket和XMLSocket, 这种方式更加高效, 便捷.</p>
<p>Spring提供了一个WebSocketHandler接口, 该接口定义了5个WebSocket相关的接口方法. Spring拥有一个抽象实现类AbstractWebSocketHandler, 继承该类便可以选择性的实现感兴趣的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Oveeride</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessageP</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 处理文本</span></span><br><span class="line">    System.out.println(<span class="string">"收到消息"</span> + message.getPayload());</span><br><span class="line">    <span class="comment">// 模拟延时</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">"发送消息: Hello, world!"</span>);</span><br><span class="line">    session.sendMessage(<span class="keyword">new</span> TextMessage(<span class="string">"hello world!"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"建立连接"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"关闭连接"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了重载WebSocketHandler中所定义的5个方法外, AbstractWebSocketHandler还定义了以下三个方法:</p>
<ul>
<li>handleTextMessage: 处理文本消息类型</li>
<li>handleBinaryMessage: 处理二进制消息类型</li>
<li>handlePongMessage: 处理Pong消息类型</li>
</ul>
<p>这是handleMessage()方法针对具体不同类型消息处理的实现. </p>
<p>还需要在Spring 容器上下文中增加相关的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将helloHandler映射到/hello</span><br><span class="line"><span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">handler</span>=<span class="string">"helloHandler"</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 声明MyWebSocketHandler Bean</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloHandler"</span> <span class="attr">class</span>=<span class="string">"com.smart.web.MyWebSocketHandler"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="WebSocket的限制"><a href="#WebSocket的限制" class="headerlink" title="WebSocket的限制"></a>WebSocket的限制</h4><p>不是所有的浏览器都支持WebSocket, 服务器端Tomcat8.0， Jetty 7.0才开始支持WebSocket</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h4><p>在web.xml中配置DispatcherServlet, 使其可以捕获所有的请求</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>smart<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>采用<code>mvc:default-servlet-handler/&gt;</code></p>
<p>在Spring MVC配置文件中配置<code>&lt;mvc:default-servlet-handler/&gt;</code>后, 会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler, 对进入DispatcherServlet的URL进行筛选. 如果是静态资源的请求, 将该请求转由Web应用服务器默认的Servlet处理; 如果不是静态资源的请求, 由DispatcherServlet继续处理</p>
<p>一般Web应用服务器默认的Servlet名称都是default, 因此DefaultServletHttpRequestHandler可以找到, 如果默认Servlet名称不是default需要通过default-servlet-name属性指定</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> <span class="attr">default-servlet-name</span>=<span class="string">"yourServerDefaultServletName"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>采用<code>&lt;mvc:resources/&gt;</code></p>
<p><code>&lt;mvc:resources/&gt;</code>由Spring MVC框架自己处理静态资源, 并添加一些游泳的附加功能</p>
<p><code>&lt;mvc:resources/&gt;</code>允许静态资源放置在任何地方, 通过location属性指定静态资源的位置, location属性是Resource类型, 可以使用”classpath:”等资源前缀指定资源位置.</p>
<p><code>&lt;mvc:resources/&gt;</code>可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间, 一般可将该时间设置为一年, 在输出静态资源时, 会根据配置设置好响应报文头的Expires和Cache-Control值</p>
<p>Spring MVC上下文配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/resources/**/"</span> <span class="attr">location</span>=<span class="string">"/,classpath:/META-INF/publicResources/"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以通过cache-period属性设置静态资源的客户端浏览器中的缓存有效时间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/resources/**/"</span> <span class="attr">location</span>=<span class="string">"/,classpath:/META-INF/publicResources/"</span> <span class="attr">cache-period</span>=<span class="string">"31536000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="装配拦截器"><a href="#装配拦截器" class="headerlink" title="装配拦截器"></a>装配拦截器</h4><p>当收到请求时, DispatcherServlet将请求交给处理器映射, 让它找出对应该请求的HandlerExecutionChain对象.</p>
<p>HandlerExecutionChain是一个执行链, 包含一个处理该请求的处理器, 若干个对该请求实施拦截的拦截器(HandlerInterceptor).</p>
<p>当HandlerMapping返回HandlerExecutionChain后, DispatcherServlet将请求交给定义在HandlerExecutionChain中的拦截器后处理器一并处理</p>
<p>HandlerExecutionChain负责处理请求并返回ModelAndView的处理执行链. 请求在被Handler执行的前后, 链中装配的HandlerInterceptor会实施拦截操作</p>
<p><img src="/2019/04/20/精通Spring-4.x读书笔记-Spring-MVC/HandlerExecutionChain的结构.png" alt="HandlerExecutionChain的结构"></p>
<p>拦截器的几个接口方法</p>
<ul>
<li>boolean preHandler(HttpServletRequest request, HttpServletResponse response, Object handler): 请求到达Handler之前, 先执行这个前置处理方法. 该方法返回false时, 请求直接返回, 不会传递到链中的下一个拦截器, 更不会传递到处理器链末端的Handler. </li>
<li>void postHandler(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView): 在请求被HandlerAdapter执行后, 执行这个后置方法</li>
<li>void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex): 在响应已经被渲染后, 执行该方法</li>
</ul>
<p>DispatcherServlet通过HandlerAdapter适配器对Handler进行封装, 并按统一的适配器接口对Handler处理方法进行调用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">path</span>=<span class="string">"/secure/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.web.MyInterceptor"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>Spring MVC通过HandlerExceptionResolver处理程序的异常, 包括处理器映射, 数据绑定及处理器执行时发生的异常. HandlerExceptionResolver仅有一个接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ModelAndView <span class="title">resolverException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object Handler, Exception ex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>发生异常时, Spring MVC将调用resolveException()方法, 并转到ModelAndView对应的视图中.</p>
<p>HandlerExceptionResolver有四个实现类</p>
<p>DefaultHandlerExceptionResolver, SimpleMappingExceptionResolver, AnnotationMethodHandlerExceptionResolver, ResponseStatusExceptionResolver</p>
<ol>
<li><p>DefaultHandlerExceptionResolver</p>
<p>默认装配了DefaultHandlerExceptionResolver, 它将Spring MVC框架的异常转换为相应的响应状态码</p>
<p>|                异常类型                 |            响应状态码             |<br>| :————————————-: | :——————————-: |<br>|     ConversionNotSupportedException     |       500(Web服务内部错误)        |<br>|   HttpMediaTypeNotAcceptableException   | 406(无和请求accept匹配的MIME类型) |<br>|   HttpMediaTypeNotSupportedException    |       415(不支持的MIME类型)       |<br>|     HttpMessageNotReadableException     |            400(坏请求)            |<br>|     HttpMessageNotWritableException     |                500                |<br>| HttpRequestMethodNotSupportedException  |       405(不支持的请求方法)       |<br>| MissingServletRequestParameterException |                400                |<br>|  NoSuchRequestHandlingMethodException   |       404(找不到匹配的资源)       |<br>|          TypeMismatchException          |                400                |</p>
<p>可以在web.xml中为响应码配置一个对应的页面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>AnnotationMethodHandlerExceptionResolver</p>
<p>Spring MVC默认注册了AnnotationMethodHandlerExceptionResolver, 允许通过@ExceptionHandler注解指定处理特定异常的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(path=<span class="string">"/throwException"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">throwException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>&gt;<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ddd"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(RuntimeException.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(RuntimeException re, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/error.jsp"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标注@ExceptionHandler的异常处理方法只能对同一处理类中的其他处理方法进行异常响应处理.</p>
<p>ResponseStatusExceptionResolver和AnnotationMethodHandlerExceptionResolver类似, 允许通过@ResponseStatus注解标注一个方法, 拥有处理特定类型的响应码</p>
</li>
<li><p>SimpleMappingExceptionResolver</p>
<p>对所有异常进行统一处理, 它将异常类名映射为视图名, 即发生异常时使用对应的视图报告异常</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"org.springframework.dao.DataAccessException"</span>&gt;</span>dataAccessFailure<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"org.springframework.transaction.TransactionException"</span>&gt;</span>dataAccessFailure<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="RequestContextHolder的使用"><a href="#RequestContextHolder的使用" class="headerlink" title="RequestContextHolder的使用"></a>RequestContextHolder的使用</h4><p>RequestContextHolder能够在Controller中获取request和session对象. 使用方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br></pre></td></tr></table></figure>
<p>需要在web.xml中配置一个监听器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.context.request.RequestContetListener</span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

