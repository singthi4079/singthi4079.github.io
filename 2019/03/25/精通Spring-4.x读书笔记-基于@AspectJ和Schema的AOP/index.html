<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Blue">
  <!-- Open Graph Data -->
  <meta property="og:title" content="精通Spring-4.x读书笔记-基于`@AspectJ`和Schema的AOP">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="Blue的博客">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://singthi4079.github.ioundefined">
  
    <link rel="alternate" href="/atom.xml" title="Blue的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Blue的博客</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">精通Spring-4.x读书笔记-基于`@AspectJ`和Schema的AOP</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Blue</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-03-25</span>
            <span class="time">07:25:26</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Spring/">#Spring</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>Spring在新版本中对AOP功能进行重要增强:</p>
<ul>
<li>新增基于Schema的配置支持, 为AOP专门提供了aop命名空间</li>
<li>新增对AspectJ切点表达式语言的支持. Spring使用和@AspectJ相同风格的注解, 并通过AspectJ提供的注解库和解析库处理切点, 由于Spring只支持方法级的切点, 仅对@AspectJ提供有限支持.</li>
<li>可以无缝集成AspectJ. AspectJ提供了语言级切面的实现.</li>
</ul>
<p><strong>注解知识</strong>:</p>
<p>注解是代码的附属信息, 它遵守一个基本原则: 注解不能直接干扰程序代码的运行, 无论增加或删除注解, 代码都能正常运行.</p>
<p>Java语言解析器会忽略这些注解, 由第三方工具负责对注解进行处理. 第三方工具可以利用代码中的注解间接控制程序代码的运行, 通过Java的反射机制读取注解的信息, 根据这些信息更改目标程序逻辑.</p>
<p>一个简单的注解类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 声明注解的保留期限</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">// 2. 声明可以使用改注解的目标类型</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHON)</span><br><span class="line"><span class="comment">// 定义注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NeedText &#123;</span><br><span class="line">  <span class="comment">// 声明注解成员</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规定使用<code>@interface</code>修饰定义注解类. 成员的声明有以下限制:</p>
<ul>
<li>成员无入参, 无抛出异常的方式声明</li>
<li>通过default为成员指定默认值, 也可以不指定默认值</li>
<li>成员类型受限. 包括原始类型及其封装类, String, Class, enums, 注解类型.]</li>
</ul>
<p><code>1</code>和<code>2</code>是Java预定义的注解, 成为元注解. 被Java编译期使用, <code>@Retention(RetentionPolicy.RUMTIME)</code>表示NeedTest这个注解可以在运行期被JVM读取. 注解的保留期限类型在<code>java.lang.annotation.Retention</code>类定义:</p>
<ul>
<li>SOURCE: 仅保留在目标类代码的源代码文件中, 对应的字节码文件不再保留</li>
<li>CLASS: 目标类代码的字节码文件中, 但类加载器加载字节码文件时不会将注解信息加载到JVM, 即运行期不能获取注解信息</li>
<li>RUNTIME: 在目标类加载到JVM后依然保留, 在运行期可以通过反射机制读取类中的注解信息</li>
</ul>
<p><code>Target(ElementType.METHOD)</code>表示这个注解只能应用在目标类的方法上, 注解的应用目标在<code>java.lang.annotation.ElemeentType</code>类中定义:</p>
<ul>
<li>Type: 类, 接口, 注解类, Enum声明处, 称为类型注解</li>
<li>FIELD: 类成员变量或常量声明处, 称为域值注解</li>
<li>METHOD: 方法声明处, 称为方法注解</li>
<li>PARAMETER: 参数声明, 称为参数注解</li>
<li>CONSTRUCTOR: 构造函数声明处, 称为构造函数注解</li>
<li>LOCAL_VARIABLE: 局部变量声明处, 称为局域变量注解</li>
<li>ANNOTATION_TYPE: 注解类声明处, 称为注解类注解, ElementType.TYPE包括ElementType.ANNOTATION_TYPE</li>
<li>PACKAGE: 包声明处, 称为包注解</li>
</ul>
<p>当注解只有一个成员时, 成员名必须为<code>value()</code>. 可以没有成员.</p>
<p>所有注解类隐式集成<code>java.lang.annotation.Annotation</code>, 但不允许显式继承其他接口</p>
<p>在Java 5.0中, Package, Class, Constructor, Method, Field等反射对象都新增了访问注解信息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>着手使用@AspectJ</strong>:</p>
<p>@AspectJ采用注解来描述切点, 增强, 和使用Pointcut, Advice接口描述前点和增强, 并用Advisor整合两者描述切面, 本质上是相同的</p>
<p>需要引入asm模块, asm是轻量级的字节码处理框架, Java的反射机制无法获取入参名, 利用asm处理@AspectJ中所描述的方法入参名</p>
<p>还需要添加aspectj.weaver和aspectj.tools类包依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveWaiter</span> <span class="keyword">implements</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@AspectJ注解定义一个切面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过该注解将类标识为一个切面</span></span><br><span class="line"><span class="meta">@AspectJ</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreGreetingAspect</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义切点和增强类型</span></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"execution(* greetTo(..))"</span>)</span><br><span class="line">  <span class="comment">// 增强的横切逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeGreeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"How ara you"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个切面没有实现特殊的接口, 只是一个普通的POJO, 只是使用了<code>@AspectJ</code>注解.</p>
<p>第三方处理程序通过类是否拥有<code>@AspectJ</code>注解判断其是否为一个切面</p>
<p>在方法定义前标注<code>@Before</code>注解, 并提供成员值<code>execution(* greetTo(..))</code>表示前置增强, 成员值是一个<code>@AspectJ</code>切点表达式, 表示: 在目标类的greetTo()方法上织入增强, greetTo()方法可以带任意参数和任意返回值</p>
<p><code>beforeGreeting()</code>方法是增强使用的横切逻辑</p>
<p><img src="/2019/03/25/精通Spring-4.x读书笔记-基于@AspectJ和Schema的AOP/切面的构成信息.png" alt="切面的构成信息"></p>
<p>PreGreetingAspect相当于<code>BeforeAdvice</code>, <code>NameMatcheMethodPointcut</code>, <code>DefaultPointcutAdvisor</code>三者联合表达的信息</p>
<p>通过<code>AspectJProxyFactory</code>为<code>NaiveWaiter</code>生产织入<code>PreGreetingAspect</code>切面的代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJProxyText</span> </span>&#123;</span><br><span class="line">  Waiter target = <span class="keyword">new</span> NaiveWaiter();</span><br><span class="line">  AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory();</span><br><span class="line">  <span class="comment">// 设置目标对象</span></span><br><span class="line">  factory.setTarget(target);</span><br><span class="line">  <span class="comment">// 添加切面类</span></span><br><span class="line">  factory.addAspect(PreGreetingAspect.class);</span><br><span class="line">  <span class="comment">// 生成织入切面的代理对象</span></span><br><span class="line">  Waiter proxy = factory.getProxy();</span><br><span class="line">  </span><br><span class="line">  proxy.greetTo(<span class="string">"John"</span>);</span><br><span class="line">  proxy.serveTo(<span class="string">"John"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/25/精通Spring-4.x读书笔记-基于@AspectJ和Schema的AOP/输出信息.png" alt="输出信息"></p>
<p>通过配置使用<code>@AspectJ</code>切面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 目标Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"waiter"</span> <span class="attr">class</span>=<span class="string">"com.smart.NaiveWaiter"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用@AspectJ注解的切面类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.aspectj.PreGreetingAspect"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动代理创建器, 自动将@AspectJ注解切面类织入目标Bean中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>自动代理创建器能够将<code>@AspectJ</code>注解切面类自动织入目标Bean中.</p>
<p>使用基于Schema的aop命名空间进行配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于@AspectJ切面的驱动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"waiter"</span> <span class="attr">class</span>=<span class="string">"com.smart.NaiveWaiter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.aspectj.PreGreetingAspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;aop:aspectj-autoproxy /&gt;</code>自动为Spring容器中所有匹配<code>@AspectJ</code>切面的Bean创建代理, 完成切面织入. 内部依旧采用<code>AnnotationAwareAspectJAutoProxyCreator</code>进行自动代理的创建工作, 只是被<code>&lt;aop:aspectj-autoproxy /&gt;</code>隐藏了.</p>
<p><code>&lt;aop:aspectj-autoproxy /&gt;</code>有一个<code>proxy-target-class</code>属性, 默认为false, 表示采用JDK动态代理技术织入增强, 为true时, 表示使用CGLib动态代理技术织入增强.</p>
<p><strong>@AspectJ语法基础</strong>：</p>
<p>AspectJ的切点表达式由关键字和操作参数组成.</p>
<p>Spring支持9个<code>@AspectJ</code>切点表达式函数, 大致分为4中类型</p>
<ul>
<li>方法切点函数: 描述目标类方法的信息定义连接点</li>
<li>方法入参切点函数: 描述目标类方法入参的信息定义连接点</li>
<li>目标类切点函数: 描述目标类类型的信息定义连接点</li>
<li>代理类切点函数: 描述目标类的代理类的信息定义连接点</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>函数</th>
<th>入参</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法切点函数</td>
<td>execution()</td>
<td>方法匹配模式串</td>
<td>表示满足某一匹配模式的所有目标类方法连接点, 如<code>execution(* greetTo(..))</code> 表示所有目标类的greetTo()方法</td>
</tr>
<tr>
<td>方法切点函数</td>
<td>@annotation()</td>
<td>方法注解类名</td>
<td>表述标注了特定注解的目标类方法连接点, 如<code>@annotation(com.smart.NeedTest)</code>表示任何标注了<code>@NeedTest</code>注解的目标类方法</td>
</tr>
<tr>
<td>方法入参函数</td>
<td>args()</td>
<td>类名</td>
<td>通过判别目标类方法运行时入参对象的类型定义指定连接点</td>
</tr>
<tr>
<td>方法入参函数</td>
<td>@args()</td>
<td>类型注解类名</td>
<td>通过判别目标类的方法运行时入参对象的类是否标注特定注解来指定连接点</td>
</tr>
<tr>
<td>目标类切点函数</td>
<td>within()</td>
<td>类名匹配串</td>
<td>表示特定域下的所有连接点. <code>within(com.smart.service.*)</code>表示com.smart.service包下的所有类的所有方法</td>
</tr>
<tr>
<td>目标类切点函数</td>
<td>target()</td>
<td>类名</td>
<td>假如目标类案类型匹配于指定类, 则目标类的所有连接点匹配这个切点.</td>
</tr>
<tr>
<td>目标类切点函数</td>
<td>@within()</td>
<td>类型注解类名</td>
<td>假如目标类案类型匹配于某个类A, 且类A标注了特定注解, 则目标类的所有连接点匹配这个切点</td>
</tr>
<tr>
<td>目标类切点函数</td>
<td>@target()</td>
<td>类型注解类名</td>
<td>假如目标类标注了特定注解, 则目标类的所有连接点都匹配该切点.</td>
</tr>
<tr>
<td>代理类切点函数</td>
<td>this()</td>
<td>类名</td>
<td>代理类按类型匹配于指定类, 则被代理的目标类的所有连接点都匹配该切点.</td>
</tr>
</tbody>
</table>
<p>在函数入参中使用通配符, <code>@AspectJ</code>支持3中通配符:</p>
<ul>
<li>*: 匹配任意字符, 只能匹配上下文中的一个元素</li>
<li>..: 匹配任意字符, 可以匹配上下文中的多个元素, 在表示类时, 必须和*联合使用, 而在表示入参时则单独使用</li>
<li>+: 表示按类型匹配指定类的所有类, 必须跟在类名后面. 继承或扩展指定类的所有类, 同时还包括指定类本身</li>
</ul>
<p>切点函数之间可以进行逻辑运算, 组成复合切点. Spring支持一下切点运算符:</p>
<ul>
<li>&amp;&amp;: 与操作符, 相当于切点的交集运算. and是等效运算符</li>
<li>||: 或运算符, 相当于切点的并集运算. or是等效运算符</li>
<li>!: 非运算符, 相当于切点的反集运算, not是等效的操作符</li>
</ul>
<p><code>@AspectJ</code>为各种增强类型提供了不同的注解, 注解类拥有若干哥成员, 可以通过这些成员完成定义切点信息, 绑定链接点参数等操作. </p>
<ol>
<li><p>@Before</p>
<p>前置增强, 拥有两个成员:</p>
<ul>
<li>value: 用于定义切点</li>
<li>argNames: 由于无法通过Java反射机制获取方法入参名, 如果在Java编译时未启用雕饰信息, 或需要运行期解析切点, 就必须通过这个成员指定注解所标注增强方法等入参名, 多个参数名用逗号分隔.</li>
</ul>
</li>
<li><p>@AfterReturning</p>
<p>后置增强, 相当于AfterReturningAdvice, 拥有4个成员:</p>
<ul>
<li>value: 用于定义切点</li>
<li>pointcut: 表示切点信息, 显式指定pointcut值, 会覆盖value设置的值</li>
<li>returning: 将目标对象方法的返回值绑定给增强的方法</li>
<li>argNames: 如前所述</li>
</ul>
</li>
<li><p>@Arount</p>
<p>环绕增强, 相当于MethodInterceptor. 拥有两个成员:</p>
<ul>
<li>value: 用于定义切点</li>
<li>argNames: 如前所述</li>
</ul>
</li>
<li><p>@AfterThrowing</p>
<p>抛出增强, 相当于ThrowsAdvice, 拥有4个成员</p>
<ul>
<li>value: 用于定义切点</li>
<li>pointcut: 和value同义</li>
<li>throwing: 将抛出的异常绑定到增强方法中</li>
<li>argNames: 如前所述</li>
</ul>
</li>
<li><p>@After</p>
<p>Final增强, 不管是抛出异常还是正常退出, 都会执行, 没有对应的增强接口. 可以看成是ThrowsAdvice和AfterReturningAdvice的混合物, 一般用于释放资源, 拥有两个成员:</p>
<ul>
<li>value: 用于定义切点</li>
<li>argNames: 如前所述</li>
</ul>
</li>
<li><p>@DeclareParents</p>
<p>引介增强, 相当于IntroductionInterceptor, 拥有两个成员:</p>
<ul>
<li>value: 用于定义切点, 表示在那个目标类上添加引介增强</li>
<li>defaultImpl: 默认的接口实现</li>
</ul>
</li>
</ol>
<p><strong>切点函数详解</strong>:</p>
<ol>
<li><p>@annotation(): 表示标注了某个注解的所有方法. </p>
</li>
<li><p>execution(): 最常用的切点函数, 语法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(参数模式) &lt;异常模式?&gt;)</span><br></pre></td></tr></table></figure>
<p>除了返回类型模式, 方法名模式, 参数模式外, 其他项都是可选的.</p>
<p>2.1 通过方法签名定义切点:</p>
<ul>
<li>execution(public <em> </em>(..)): 匹配所有目标类的public方法</li>
<li>execution(<em> </em>To(..)): 匹配目标类所有已To为后缀的方法</li>
</ul>
<p>2.2 通过类定义切点:</p>
<ul>
<li>execution(<em> com.smart.Waiter.</em>(..)): 匹配Waiter接口的所有方法</li>
<li>execution(<em> com.smart.Waiter+</em>(..)): 匹配Waiter接口及其所有实现类的方法</li>
</ul>
<p>2.3 通过类包定义切点:</p>
<ul>
<li>execution(<em> com.smart.</em>(..)): 匹配com.smart包下所有类的所有方法</li>
<li>execution(<em> com.smart..</em>(..)): 匹配com.smart包, 子孙包下所有类的所有方法</li>
<li>execution(<em> com.</em>.<em>Dao.find</em>(..)): 匹配包名前缀为com的任何包下类名后缀为Dao的方法, 方法名必须以find为前缀.</li>
</ul>
<p>2.4. 通过方法入参定义切点:</p>
<p>方法入参部分比较复杂, “*”表示任意类型的参数, “..”表示任意类型的参数且参数个数不限 </p>
<ul>
<li>execution(* joke(String, int)): 匹配joke(String, int)方法, 参数类型顺序必须相同. java.lang包下的类可以直接使用类名, 否则巴西使用全限定类名</li>
<li>execution(<em> joke(String, </em>)): 匹配目标类中的joke()方法, 第一个入参为String, 第二个入参为任意类型, 只有两个入参</li>
<li>execution(* joke(String, ..)): 匹配目标类中的joke()方法, 第一个入参为String, 后面可以有任意个入参且入参类型不限.</li>
<li>execution(* joke(Object+)): 匹配目标类中的joke()方法, 拥有一个入参, 切入参是Object类型或该类的子类.</li>
</ul>
</li>
<li><p>args()和@args()</p>
<p>args()函数的入参是类名, @args()函数的入参必须是注解类的类名. 在args()中使用”+”通配符, 没有意义.</p>
<p>3.1 args(): 接受一个类名, 表示目标类方法入参对象是指定类(包含子类)时, 切点匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args(com.smart.Waiter)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *(com.smart.Waiter+))</span><br></pre></td></tr></table></figure>
<p>3.2 @args()</p>
<p>接收一个注解类的类名, 当方法在运行时的入参对象标注了指定注解时, 匹配切点</p>
</li>
<li><p>within()</p>
<p>通过类匹配模式串声明切点, within()函数定义的连接点是针对目标类而言的, 而非针对运行期对象的类型而已, 和execetion()是相同的. </p>
<p>within()所指定的连接点最小范围只能是类, 而execution()所指定的连接点可以大到包, 小到方法入参.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(&lt;类匹配模式&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li>within(com.smart.NaiveWaiter): 匹配目标类的所有方法.</li>
<li>within(com.stmart.*): 匹配com.smart包中的所有类, 但不包括子孙包。</li>
<li>within(com.smart..*): 匹配com.smat包及子孙包中的所有类.</li>
</ul>
</li>
<li><p>@within()和@target()</p>
<p>只接受注解类名作为入参, @target(M)匹配任意标注了@M的目标类, 而@within(M)匹配标注了@M的类及子孙类</p>
</li>
<li><p>target()和this()</p>
<p>target()切点函数通过判断目标类是否按类型匹配指定类来觉得连接点是否匹配类, this()函数通过判断代理类是否按类型匹配指定类来决定是否切点匹配. “+”通配符没有意义</p>
<p>6.1 target(): tarrget(M)表示如果目标类案类型匹配于M, 则目标类的所有方法都匹配切点</p>
<ul>
<li>target(com.smart.Waiter): NaiveWaiter的所有方法匹配切点, 包括未在接口中定义的方法</li>
<li>target(com.smart.Waiter+)和target(com.smart.Waiter)等价</li>
</ul>
<p>6.2 this(): 判断代理对象的类是否按类型匹配于指定类, 如果匹配, 则代理对象的所有连接点匹配切点.</p>
</li>
</ol>
<p><strong>@AspectJ进阶</strong></p>
<p>切点复合运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 与运算</span></span><br><span class="line">  <span class="meta">@After</span>(<span class="string">"within(com.smart.*) &amp;&amp; execution(* greetTo(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greeTofun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 非与运算</span></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"!target(com.smart.NaiveWaiter) &amp;&amp;execution(* serveTo(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notServeInNaiveWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 或运算</span></span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"target(com.smart.Waiter) || target(com.smart.Seller)"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waiterOrSeller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;&amp;运算符匹配com.smart包中所有greetTo()方法的切点</p>
<p>通过!和&amp;&amp;运算匹配所有serveTo方法并且改方法不位于NaiveWaiter目标类的切点</p>
<p>||运算符匹配Waiter和Seller接口实现类所有连接点的切点</p>
<p>命名切点:</p>
<p>希望在其他地方重用一个切点, 可以通过@Pointcut注解及切面类方法对切点进行命名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNamePointcut</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过注解方法inPackage()对该切点进行命名, 方法可视域修饰符为private, 表明该切点只能在本切面类中使用</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"within(com.smart.*)"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inPackage</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过注解方法grreetTo()对该切点进行命名, 方法可视域修饰符为protected, 表明该切点和呀在当前包中的切面类, 子切面类中使用</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(* greetTo(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 引用命名切点定义的切点, 本切点也是命名切点, 它对应的可视域为public</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"inPackage() and greetTo()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inPkgGreetTo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名切点的使用类方法作为切点的名称, 此外方法的访问修饰符还控制了切点的可引用性.</p>
<p> <img src="/2019/03/25/精通Spring-4.x读书笔记-基于@AspectJ和Schema的AOP/命名切点的结构.png" alt="命名切点的结构"></p>
<p>增强织入的顺序</p>
<p>一个连接点可以同时匹配多个切点. 规则如下:</p>
<ul>
<li>如果增强在同一个切面类中声明, 则依照增强在切面类中定义的顺序进行织入</li>
<li>如果增强位于不同的切面中, 且这些切面类都实现了org.springframework.core.Ordered接口, 则由接口方法的顺序号决定</li>
<li>如果增强位于不同的切面类中, 这些切面类都没有实现org.spring.framework.core.Ordered接口, 织入顺序不确定</li>
</ul>
<p><img src="/2019/03/25/精通Spring-4.x读书笔记-基于@AspectJ和Schema的AOP/增强织入顺序.png" alt="增强织入顺序"></p>
<p>访问连接点信息</p>
<p>AspectJ使用org.aspectj.lang.JoinPoint接口表示目标类连接点对象. 如果是环绕增强, 使用org.aspectj.lang.ProceedingJoinPoint表示连接点对象, 该类是JoinPoint的子接口. 任何增强方法都可以通过第一个入参声明为JoinPoint访问连接点上下文信息.</p>
<p>主要方法:</p>
<ol>
<li><p>JoinPoint</p>
<ul>
<li>Object[] getArgs(): 获取连接点方法运行时的入参列表</li>
<li>Signature getSignature(): 获取连接点的方法签名对象</li>
<li>Object getTarget(): 获取连接点所在的目标对象</li>
<li>Object getThis(): 获取代理对象本身</li>
</ul>
</li>
<li><p>ProceedingJoinPoint: 继承与JoinPoint接口, 新增两个执行连接点方法的方法</p>
<ul>
<li>Object proceed() throws java.lang.Throwable: 通过反射执行目标对象的连接点处的方法</li>
<li>Object proceed(Object[] args) throw Throwable: 通过反射执行目标对象连接点处的方法, 使用新的入参替换原来的入参.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 环绕增强</span></span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"execution(* geetTo(..)) &amp;&amp; target(com.smart.NaiveWaiter)"</span>)</span><br><span class="line">  <span class="comment">// 声明连接点入参</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">joinPointAccess</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 访问连接点信息</span></span><br><span class="line">    System.out.println(<span class="string">"args[0]:"</span> + pjp.getArgs()[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(<span class="string">"signature: "</span> + pjp.getTarget.getClass());</span><br><span class="line">    <span class="comment">// 通过连接点执行目标对象方法</span></span><br><span class="line">    pjp.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>绑定连接点方法入参:</p>
<p>args(), this(), target(), @args(), @within(), @target, @annotation() 这7个函数除了可以指定类名外, 还可以指定参数名, 将目标对象连接点上的方法入参绑定到增强的方法中.</p>
<p>args()用于绑定连接点方法的入参</p>
<p>@annotation()用于绑定连接点方法的注解对象</p>
<p>@args()用于绑定连接点方法入参的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"target(com.smart.NaiveWaiter) &amp;&amp; args(name, num)"</span>)</span><br><span class="line">  <span class="comment">// 增强方法接受连接点的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindJoinPointParams</span><span class="params">(<span class="keyword">int</span> num, String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">    System.out.println(<span class="string">"num: "</span> + num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>args(name, num)</code>进行连接点参数绑定, 当args()函数入参为参数名时, 包括两方面的信息</p>
<p>1) 连接点匹配规则信息: 连接点方法的第一个入参是String类型, 第二个入参是int类型</p>
<p>2) 连接点方法入参和增强方法入参的绑定信息: 连接点方法的第一个入参绑定到增强方法的name参数上, 第二个入参绑定到增强方法的num参数上</p>
<p>切点匹配和入参绑定的过程:</p>
<p>首先, args()根据参数名称在增强方法中查到名称相同的入参并获知对应的类型, 这样就知道了匹配连接点方法的入参类型</p>
<p>其次, 连接点方法入参类型所在的位置则由参数名在args()函数中声明的位置决定</p>
<p><img src="/2019/03/25/精通Spring-4.x读书笔记-基于@AspectJ和Schema的AOP/切点匹配和入参绑定过程.png" alt="切点匹配和入参绑定过程"></p>
<p>绑定代理对象</p>
<p>使用this()和target()函数可以绑定代理对象实例, 在通过类实例名绑定对象时, 依然具有原来的连接点匹配的功能, 只不过类名时通过增强方法中同名入参的类型间接决定.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"this(waiter)"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindProxyObj</span><span class="params">(Waiter waiter)</span> </span>&#123;</span><br><span class="line">      System.out.println(waiter.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切点表达式首先按类变量名<code>waiter</code>查找增强方法的入参列表, 进而获取类变量名对应的类为com.smart.Waiter, 这样就指定了切点定义为<code>this(com.smart.Waiter)</code>, 即所有代理对象为Waiter类的所有方法匹配该切点. 增强方法通过waiter入参绑定目标对象.</p>
<p>绑定类注解对象</p>
<p>@within()和@target()函数可以将目标类的注解对象绑定到增强方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"@within(m)"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindTypeAnnoObject</span><span class="params">(Monitorable m)</span> </span>&#123;</span><br><span class="line">    System.out.println(m.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在NaiveWaiter类中标注了@Monitorable注解, 所有NaiveWaiter Bean都匹配切点</p>
<p>绑定返回值</p>
<p>在后置增强中, 可以通过returning绑定连接点返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturing</span>(value=<span class="string">"target(com.smart.SmartSeller)"</span>, returning=<span class="string">"retVal"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bingReturnValue</span><span class="params">(<span class="keyword">int</span> retVal)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"returnValue: "</span> + retVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>returning处的值必须和增强方法的入参名字相同</p>
<p>增强方法的入参类型必须和连接点方法的返回值类型匹配</p>
<p>绑定抛出的异常</p>
<p>连接点抛出的异常必须使用AfterThrowing注解的throwing成员进行绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">  <span class="meta">@AfterThrowing</span>(value=<span class="string">"target(com.smart.SmartSeller)"</span>, throwing=<span class="string">"iae"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindException</span><span class="params">(IllegalArgumentException iae)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"exception: "</span> + iae.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throwing指定的异常名必须和增强方法的入参的异常名相同.</p>
<p>这个异常增强只有在连接点抛出异常 <code>instanceof IllegalArgumentException</code>时才匹配.</p>
<p><strong>基于Schema配置切面</strong></p>
<p>使用基于Schema的切面定义后, 切点, 增强类型的注解信息从切面类中剥离出来, 原来的切面类也就蜕变成为真正意义上的POJO</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">"target(com.smart.NaiveWaiter) and execution (* greetTo(..))"</span> <span class="attr">method</span>=<span class="string">"preGreeting"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adviceMethods"</span> <span class="attr">class</span>=<span class="string">"com.smart.schema.AdviceMethods"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"naiveWaiter"</span> <span class="attr">class</span>=<span class="string">"com.smart.NaiveWaiter"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"naughtyWaiter"</span> <span class="attr">class</span>=<span class="string">"com.smart.NaughtyWaiter"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用一个<code>&lt;aop:aspect&gt;</code>元素标签定义切面, 内部可以定义多个增强.</p>
<p>在<code>&lt;aop:config&gt;</code>元素中可以定义多个切面.</p>
<p>切面引用了adviceMethods Bean, 该Bean是增强方法所在的类</p>
<p>通过<code>&lt;aop:before&gt;</code>声明一个前置增强, 并通过pointcut属性定义切点表达式, 切点表达式的语法和<code>@AspectJ</code>所用的语法相同</p>
<p>通过method属性指定增强的方法, 该方法应该是advicemethods Bean中的方法</p>
<p>一个配置文件可以同时定义多个<code>&lt;aop:config&gt;</code>, 不同的<code>&lt;aop:config&gt;</code>可以采用不同的代理技术</p>
<p>配置命名切点:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义命名切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"greetToPointcut"</span> <span class="attr">expression</span>=<span class="string">"target(com.smart.NaiveWaiter) and execution(* greetTo(..))"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"preGreeting"</span> <span class="attr">pointcut-ref</span>=<span class="string">"greetToPointcut"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;aop:pointcut&gt;</code>如果位于<code>&lt;aop:aspect&gt;</code>元素中, 则命名切点只能被当前<code>&lt;aop:aspect&gt;</code>内定义的元素访问.</p>
<p>为了能被整个<code>&lt;aop:config&gt;</code>元素中定义的所有增强访问, 必须在<code>&lt;aop:config&gt;</code>元素下定义切点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 定义命名切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"greetToPointcut"</span> <span class="attr">expression</span>=<span class="string">"target(com.smart.NaiveWaiter) and execution(* greetTo(..))"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"preGreeting"</span> <span class="attr">pointcut-ref</span>=<span class="string">"greetToPointcut"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用切点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"postGreeting"</span> <span class="attr">pointcut-ref</span>=<span class="string">"greetToPointcut"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;aop:config&gt;</code>元素下可以定义<code>&lt;aop:pointcut&gt;</code>, <code>&lt;aop:advisor&gt;</code>, <code>&lt;aop:aspect&gt;</code>, 三者顺序为: <code>&lt;aop:pointcut&gt;</code>, <code>&lt;aop:advisor&gt;</code>, <code>&lt;aop:aspect&gt;</code></p>
<p><img src="/2019/03/25/精通Spring-4.x读书笔记-基于@AspectJ和Schema的AOP/config元素的Schema样式定义.png" alt="config元素的Schema样式定义"></p>
<p>各种增强类型的配置:</p>
<ol>
<li><p>后置增强</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturning"</span> <span class="attr">pointcut</span>=<span class="string">"target(com.smart,SmartSeller)"</span> <span class="attr">returning</span>=<span class="string">"retVal"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>returing属性必须和增强方法入参名一致.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceMethods</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(<span class="keyword">int</span> retVal)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环绕增强</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundMethod"</span> <span class="attr">pointcut</span>=<span class="string">"target(com.smart,SmartSeller)"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>环绕增强对应的方法, 可以将第一个入参声明为ProceedingJoinPoint</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceMethods</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundMetod</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抛出异常增强</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingMethod"</span> <span class="attr">pointcut</span>=<span class="string">"target(com.smart,SmartSeller)"</span> <span class="attr">throwing</span>=<span class="string">"iae"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过iae查找增强方法对应名字的入参, 进而获取需要增强的连接点匹配异常类型</p>
<p>通过throwing属性声明需要绑定的异常对象, 指定的异常名必须和增强方法对应的入参名一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceMethods</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingMehtod</span><span class="params">(IllegalArgumentException iae)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Final增强</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterMethod"</span> <span class="attr">pointcut</span>=<span class="string">"target(com.smart,SmartSeller)"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的Final增强方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdivceMethods</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引介增强</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:declare-parent</span></span></span><br><span class="line"><span class="tag">          <span class="attr">implement-interfae</span>=<span class="string">"com.smart.Seller"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">default-impl</span>=<span class="string">"com.smart.SmartSeller"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">types-matching</span>=<span class="string">"com.smart.Waiter+"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;aop:declare-parent&gt;</code>通过<code>implement-interfae</code>属性声明要实现的接口. 通过<code>default-impl</code>属性指定默认的接口实现类, 通过<code>types-matching</code>属性以<code>AspectJ</code>切点表达式语法指定哪些Bean需要引介Seller接口的实现</p>
<p><code>&lt;aop:declare-parent&gt;</code>没有method属性指定增强方法所在的Bean, 但<code>&lt;aop:aspect ref=&quot;adviceMethods&quot;&gt;</code>中带ref属性依然要指定一个增强Bean</p>
</li>
</ol>
<p>绑定连接点信息:</p>
<p>基于Schema配置的增强方法绑定连接点信息和基于<code>@AspectJ</code>绑定连接点信息所使用的方式没有什么区别</p>
<ol>
<li><p>所有增强类型对应的方法的第一个入参都可以声明为JoinPoint(环绕增强可以声明为ProceedingJoinPoint)访问连接点信息</p>
</li>
<li><p><code>&lt;aop:after-returngin&gt;</code>可以通过returning属性绑定连接点的返回值, <code>&lt;aop:after-throwing&gt;</code>可以通过throwing属性绑定连接点方法所抛出的异常</p>
</li>
<li><p>所有增强类型都可以通过绑定参数的切点函数绑定连接点方法的入参</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"bindParams"</span> <span class="attr">pointcut</span>=<span class="string">"target(com.smart.NaiveWaiter) and args(name, num, ..)"</span></span></span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>args(name, num, ..)</code>绑定连接点的两个参数, 对应的增强方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceMethods</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindParams</span><span class="params">(<span class="keyword">int</span> num, String name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Advisor配置:</p>
<p>Advisor是Spring中切面概念的对应物, 是切点和增强的复合体, 不过它仅包含一个切点和一个增强.</p>
<p>Schema可以通过<code>&lt;aop:advisor&gt;</code>配置一个Advisor. 通过advice-ref属性引用基于接口定义的增强, 通过pointcut定义切点表达式, 或通过pointcut-ref引用一个命名的切点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"testAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com..*.Waiter.greetTo(..))"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testAdvice"</span> <span class="attr">class</span>=<span class="string">"com.smart.schema.TestBeforeAdvice"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>TestBeforeAdvice是一个实现了MethodBeforeAdvice接口的增强类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method mothod, Object[] args, Object target)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>各种切面类型总结</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>@AspectJ</th>
<th><code>&lt;aop:aspect&gt;</code></th>
<th>Advisor</th>
<th><code>&lt;aop:advisor&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>前置增强</td>
<td>@Before</td>
<td><code>&lt;aop:before&gt;</code></td>
<td>MethodBeforeAdvice</td>
<td>同Advisor</td>
</tr>
<tr>
<td>后置增强</td>
<td>@AfterReturning</td>
<td><code>&lt;aop:after-returning&gt;</code></td>
<td>AfterReturningAdvice</td>
<td>同Advisor</td>
</tr>
<tr>
<td>环绕增强</td>
<td>@Around</td>
<td><code>&lt;aop:around&gt;</code></td>
<td>MethodInterceptor</td>
<td>同Advisor</td>
</tr>
<tr>
<td>异常抛出增强</td>
<td>@AfterThrowing</td>
<td><code>&lt;aop:after-throwing&gt;</code></td>
<td>ThrowsAdvice</td>
<td>同Advisor</td>
</tr>
<tr>
<td>Final增强</td>
<td>@After</td>
<td><code>&lt;aop:after&gt;</code></td>
<td>无对应接口</td>
<td>同Advisor</td>
</tr>
<tr>
<td>引介增强</td>
<td>@DeclareParents</td>
<td><code>&lt;aop:declare-parents&gt;</code></td>
<td>IntroductionInterceptor</td>
<td>同Advisor</td>
</tr>
<tr>
<td>切点定义</td>
<td>支持AspectJ切点表达式语法, 可以通过@Pointcut注解定义命名切点</td>
<td>支持AspectJ切d点表达式语法, 通过<code>&lt;aop:pointcut&gt;</code>定义命名切点</td>
<td>直接通过基于Pointcut的实现类定义切点</td>
<td>基本上和<code>&lt;aop:aspect&gt;</code>相同, 切点函数不能绑定参数</td>
</tr>
<tr>
<td>连接点方法入参绑定</td>
<td>1) 使用JoinPoint, ProceedingJoinPoint连接点对象<br>2) 使用切点函数指定参数名绑定</td>
<td>通@AspectJ<code>&lt;aop:after-returning&gt;</code></td>
<td>通过增强接口方法入参绑定</td>
<td>通Advisor</td>
</tr>
<tr>
<td>连接点方法返回值或抛出异常绑定</td>
<td>1) 在后置增强中使用@AfterReturning的returning成员绑定方法返回值<br>2) 在抛出异常增强中, 使用@AfterThrowing的throwing成员绑定方法抛出的异常</td>
<td>1) 在后置增强中, 使用<code>&lt;aop:after-returning&gt;</code>的returning属性绑定方法返回值<br>2) 在抛出异常增强中, 使用<code>&lt;aop:after-throwing&gt;</code>的throwing属性绑定方法抛出的异常</td>
<td>通过增强接口方法入参绑定</td>
<td>同Advisor</td>
</tr>
</tbody>
</table>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

